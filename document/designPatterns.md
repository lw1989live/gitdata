# 设计模式


# Head First设计模式

## 1.欢迎来到设计模式世界：设计模式入门
### 设计原则1
找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。
### 设计原则2
针对接口编程，而不是针对实现编程。
“针对接口编程”真正的意思是“针对超类型(supertype)编程”。
## 2.让你的对象知悉现况：观察者模式
## 3.装饰对象：装饰者模式
## 4.烧烤OO的精华：工厂模式
## 5.独一无二的对象：单件模式
## 6.封装调用：命令模式
## 7.随遇而安：适配器模式
## 8.封装算法：模板方法模式
## 9.管理良好的集合：迭代器与组合模式
## 10.事物的状态：状态模式
## 11.控制对象访问：代理模式
## 12.模式中的模式：复合模式
## 13.真实世界中的模式：与设计模式相处
## 14.附录A：剩下的模式




# 大话设计模式

## 第1章 代码无错就是优？——简单工厂模式
### 1.4 面向对象编程
### 1.5 活字印刷，面向对象
#### 第一，可维护
#### 第二，可复用
#### 第三，可扩展
### 1.6 面向对象的好处
 通过封装、继承、多态把程序的耦合度降低
 用设计模式使程序更加的灵活，容易修改，并且易于复用
### 1.10 简单工厂模式
 要实例化谁，应该考虑用一个单独的类来做创造实例的过程，这就是工厂

## 第2章 商场促销——策略模式
### 2.3 简单工厂实现
面向对象的编程，并不是类越多越好，类的划分，是为了封装，但分类的基础是抽象，具有相同属性和功能的对象的抽象集合都是类。
### 2.4 策略模式
策略模式（Strategy）:它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。
### 2.6 策略与简单工厂结合
### 2.7 策略模式解析
策略模式是一种定义一系列算法的方法,从概念上来看,所有这些算法完成的都是相同的工作,只是实现不同,它可以以相同的方式调用所有算法,减少了各种算法类与使用算法类之间的耦合
策略模式的Strategy类层次为Context定义了一系列的可供重用的算法或行为。继承有助于析取出这些算法中的公共功能。
策略模式的优点是简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试。
当不同的行为堆砌在一个类中时，就很难避免使用条件语句来选择合适的行为。将这些行为封装在一个个独立的Strategy类中，可以在使用这些行为的类中消除条件语句。策略模式封装了变化。
策略模式就是用来封装算法的，但在实践中，我们发现可以用它来封装几乎任何类型的规则，只要在分析过程中听到需要在不同时间应用不同的业务规则，就可以考虑使用策略模式处理这种变化的可能性。
在基本的策略模式中，选择所用具体实现的职责由客户端对象承担，并转给策略模式的Context对象。
## 第3章 拍摄UFO——单一职责原则
### 3.4 单一职责原则
单一职责原则(SRP)，就一个类而言，应该仅有一个引起它变化的原因。
### 3.5 方块游戏的设计
如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其它职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。
软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。
如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责，就应该考虑类的职责分离。
## 第4章 考研求职两不误——开放——封闭原则
### 4.2 开放-封闭原则
开放-封闭原则，是说软件实体(类、模块、函数等等)应该可以扩展，但是不可修改
对于扩展是开放的，对于更改是封闭的
### 4.3 何时应对变化
无论模块是多么的‘封闭’，都会存在一些无法对之封闭的变化。既然不可能完全封闭，设计人员必须对于他设计的模块应该对哪种变化封闭做出选择。他必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离那些变化。
等到变化发生时立即采取行动。
在我们最初编写代码时，假设变化不会发生。当变化发生时，我们就创建抽象来隔离以后发生的同类变化。
面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码。这就是‘开放-封闭’的精神所在。我们希望的是在开发工作展开不久就知道可能发生的变化。查明可能发生的变化所等待的时间越长，要创建正确的抽象就越困难。
开放-封闭原则是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是可维护、可扩展、可复用、灵活性好。开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于应用程序中的每个部分都刻意进行抽象同样不是一个好主意。拒绝在成熟的抽象的抽象本身一样重要。
## 第5章 会修电脑不会修收音机？——依赖倒转原则
### 5.3 依赖倒转原则
依赖倒转原则
A.高层模块不应该依赖低层模块。两个都应该依赖抽象。
B.抽象不应该依赖细节，细节应该依赖抽象。
针对接口编程，不要对实现编程。
5.4 里氏代换原则

## 第6章 穿什么有这么重要？——装饰模式
## 第7章 为别人做嫁衣——代理模式
## 第8章 雷锋依然在人间——工厂方法模式
## 第9章 简历复印——原型模式
## 第10章 考题抄错会做也白搭——模板方法模式
## 第11章 无熟人难办事？——迪米特法则
## 第12章 牛市股票还会亏钱？——外观模式
## 第13章 好菜没回味不同——建造者模式
## 第14章 老板回来，我不知道——观察者模式
## 第15章 就不能不换DB吗？——抽象工厂模式
## 第16章 无尽加班何时休——状态模式
## 第17章 在NBA我需要翻译——适配器模式
## 第18章 如果再回到从前——备忘录模式
## 第19章 分公司=一部门——组合模式
## 第20章 想走？可以！先买票——迭代器模式
## 第21章 有些类也需要计划生育——单例模式
## 第22章 手机软件何时统一——桥接模式
## 第23章 烤羊肉串引来的思考——命令模式
## 第24章 加薪非要老总批？——职责链模式
## 第25章 世界需要和平——中介者模式
## 第26章 项目多也别傻做——享元模式
## 第27章 其实你不懂老板的心——解释器模式
## 第28章 男人和女人——访问者模式
## 第29章 OOTV杯超级模式大赛——模式总结
## 附录A 培训实习生——面向对象基础
本章仅对涉及阅读本书需要了解的C#语言中面向对象的知识做简单的介绍。
### A.2 类与实例
一切事物皆为对象，准确的说，对象是一个自包含的实体，用一组可识别的特性和行为来标识。
类是具有相同的属性和功能的对象的抽象的集合。
实例，就是一个真实的对象。
实例化就是创建对象的过程，使用 new 关键字来创建。
### A.3 构造方法
### A.4 方法重载
### A.5 属性与修饰符
### A.6 封装
### A.7 继承
### A.8 多态
### A.9 重构
### A.10 抽象类
### A.11 接口
### A.12 集合
### A.13 泛型
### A.14 委托与事件
## 附录B 参考文献
