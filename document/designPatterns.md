# 设计模式


# Head First设计模式

## 1.欢迎来到设计模式世界：设计模式入门
### 设计工具箱
#### OO(面向对象)基础
抽象
封装
多态
继承
#### OO原则
封装变化——找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。
多用组合，少用继承
针对接口编程，不针对实现编程。——“针对接口编程”真正的意思是“针对超类型(supertype)编程”。
#### OO模式
策略模式（Strategy）:定义算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。
#### 要点
知道OO基础，并不足以让你设计出良好的OO系统。
良好的OO设计必须具备可复用、可扩充、可维护三个特性。
模式可以让我们建造出具有良好OO设计质量的系统。
模式被认为是历经验证的OO设计经验。
模式不是代码，而是针对设计问题的通用解决方案。你可以把它们应用到特定的应用中。
模式不是被发明，而是被发现。
大多数的模式和原则，都着眼于软件变化的主题。
大多数的模式都允许系统局部改变独立于其他部分。
我们常把系统中会变化的部分抽出来封装。
模式让开发人员之间有共同语言，能够最大化沟通价值。

## 2.让你的对象知悉现况：观察者模式
## 3.装饰对象：装饰者模式
## 4.烧烤OO的精华：工厂模式
## 5.独一无二的对象：单件模式
## 6.封装调用：命令模式
## 7.随遇而安：适配器模式
## 8.封装算法：模板方法模式
## 9.管理良好的集合：迭代器与组合模式
## 10.事物的状态：状态模式
## 11.控制对象访问：代理模式
## 12.模式中的模式：复合模式
## 13.真实世界中的模式：与设计模式相处
## 14.附录A：剩下的模式




# 大话设计模式

## 第1章 代码无错就是优？——简单工厂模式
### 1.4 面向对象编程
### 1.5 活字印刷，面向对象
#### 第一，可维护
#### 第二，可复用
#### 第三，可扩展
### 1.6 面向对象的好处
 通过封装、继承、多态把程序的耦合度降低
 用设计模式使程序更加的灵活，容易修改，并且易于复用
### 1.10 简单工厂模式
 要实例化谁，应该考虑用一个单独的类来做创造实例的过程，这就是工厂

## 第2章 商场促销——策略模式
### 2.3 简单工厂实现
面向对象的编程，并不是类越多越好，类的划分，是为了封装，但分类的基础是抽象，具有相同属性和功能的对象的抽象集合都是类。
### 2.4 策略模式
策略模式（Strategy）:它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。
### 2.6 策略与简单工厂结合
### 2.7 策略模式解析
策略模式是一种定义一系列算法的方法,从概念上来看,所有这些算法完成的都是相同的工作,只是实现不同,它可以以相同的方式调用所有算法,减少了各种算法类与使用算法类之间的耦合
策略模式的Strategy类层次为Context定义了一系列的可供重用的算法或行为。继承有助于析取出这些算法中的公共功能。
策略模式的优点是简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试。
当不同的行为堆砌在一个类中时，就很难避免使用条件语句来选择合适的行为。将这些行为封装在一个个独立的Strategy类中，可以在使用这些行为的类中消除条件语句。策略模式封装了变化。
策略模式就是用来封装算法的，但在实践中，我们发现可以用它来封装几乎任何类型的规则，只要在分析过程中听到需要在不同时间应用不同的业务规则，就可以考虑使用策略模式处理这种变化的可能性。
在基本的策略模式中，选择所用具体实现的职责由客户端对象承担，并转给策略模式的Context对象。
## 第3章 拍摄UFO——单一职责原则
### 3.4 单一职责原则
单一职责原则(SRP)，就一个类而言，应该仅有一个引起它变化的原因。
### 3.5 方块游戏的设计
如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其它职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。
软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。
如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责，就应该考虑类的职责分离。
## 第4章 考研求职两不误——开放——封闭原则
### 4.2 开放-封闭原则
开放-封闭原则，是说软件实体(类、模块、函数等等)应该可以扩展，但是不可修改
对于扩展是开放的，对于更改是封闭的
### 4.3 何时应对变化
无论模块是多么的‘封闭’，都会存在一些无法对之封闭的变化。既然不可能完全封闭，设计人员必须对于他设计的模块应该对哪种变化封闭做出选择。他必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离那些变化。
等到变化发生时立即采取行动。
在我们最初编写代码时，假设变化不会发生。当变化发生时，我们就创建抽象来隔离以后发生的同类变化。
面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码。这就是‘开放-封闭’的精神所在。我们希望的是在开发工作展开不久就知道可能发生的变化。查明可能发生的变化所等待的时间越长，要创建正确的抽象就越困难。
开放-封闭原则是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是可维护、可扩展、可复用、灵活性好。开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于应用程序中的每个部分都刻意进行抽象同样不是一个好主意。拒绝在成熟的抽象的抽象本身一样重要。
## 第5章 会修电脑不会修收音机？——依赖倒转原则
### 5.3 依赖倒转原则
依赖倒转原则
A.高层模块不应该依赖低层模块。两个都应该依赖抽象。
B.抽象不应该依赖细节，细节应该依赖抽象。
针对接口编程，不要对实现编程。
5.4 里氏代换原则

## 第6章 穿什么有这么重要？——装饰模式
## 第7章 为别人做嫁衣——代理模式
## 第8章 雷锋依然在人间——工厂方法模式
## 第9章 简历复印——原型模式
## 第10章 考题抄错会做也白搭——模板方法模式
## 第11章 无熟人难办事？——迪米特法则
## 第12章 牛市股票还会亏钱？——外观模式
## 第13章 好菜没回味不同——建造者模式
## 第14章 老板回来，我不知道——观察者模式
## 第15章 就不能不换DB吗？——抽象工厂模式
## 第16章 无尽加班何时休——状态模式
## 第17章 在NBA我需要翻译——适配器模式
## 第18章 如果再回到从前——备忘录模式
## 第19章 分公司=一部门——组合模式
## 第20章 想走？可以！先买票——迭代器模式
## 第21章 有些类也需要计划生育——单例模式
## 第22章 手机软件何时统一——桥接模式
## 第23章 烤羊肉串引来的思考——命令模式
## 第24章 加薪非要老总批？——职责链模式
## 第25章 世界需要和平——中介者模式
## 第26章 项目多也别傻做——享元模式
## 第27章 其实你不懂老板的心——解释器模式
## 第28章 男人和女人——访问者模式
## 第29章 OOTV杯超级模式大赛——模式总结
## 附录A 培训实习生——面向对象基础
本章仅对涉及阅读本书需要了解的C#语言中面向对象的知识做简单的介绍。
### A.2 类与实例
一切事物皆为对象，准确的说，对象是一个自包含的实体，用一组可识别的特性和行为来标识。
类是具有相同的属性和功能的对象的抽象的集合。
实例，就是一个真实的对象。
实例化就是创建对象的过程，使用 new 关键字来创建。
### A.3 构造方法
### A.4 方法重载
### A.5 属性与修饰符
### A.6 封装
### A.7 继承
### A.8 多态
### A.9 重构
### A.10 抽象类
### A.11 接口
### A.12 集合
### A.13 泛型
### A.14 委托与事件
## 附录B 参考文献


# 尚学堂JAVA设计模式
## 设计模式GOF23
将设计者的思维融入大家的学习和工作中，更高层次的思考！
创建型模式：
    单例模式、工厂模式、抽象工厂模式、建造者模式、原型模式。
结构型模式：
    适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。
行为型模式：
    模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式、访问者模式。

### 单例模式
#### 核心作用：
    保证一个类只有一个实例，并且提供一个访问该实例的全局访问点。

#### 常见应用场景：
    Windows的Task Manager（任务管理器）就是很典型的单例模式
    windows的Recycle Bin（回收站）也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。
    项目中，读取配置文件的类，一般也只有一个对象。没有必要每次使用配置文件数据，每次new一个对象去读取。
    网站的计数器，一般也是采用单例模式实现，否则难以同步。
    应用程序的日志应用，一般都何用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加。
    数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。
    操作系统的文件系统，也是大的单例模式实现的具体例子，一个操作系统只能有一个文件系统。
    Application 也是单例的典型应用（Servlet编程中会涉及到）
    在Spring中，每个Bean默认就是单例的，这样做的优点是Spring容器可以管理
    在servlet编程中，每个Servlet也是单例
    在spring MVC框架/struts1框架中，控制器对象也是单例

#### 单例模式的优点：
    由于单例模式只生成一个实例，减少了系统性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决
    单例模式可以在系统设置全局的访问点，优化环共享资源访问，例如可以设计一个单例类，负责所有数据表的映射处理

#### 常见的五种单例模式实现方式：
    主要：
        饿汉式（线程安全，调用效率高。 但是，不能延时加载。）
        懒汉式（线程安全，调用效率不高。 但是，可以延时加载。）
    其他：
        双重检测锁式（由于JVM底层内部模型原因，偶尔会出问题。不建议使用）
        静态内部类式(线程安全，调用效率高。 但是，可以延时加载)
        枚举单例(线程安全，调用效率高，不能延时加载)

#### 如何选用?
    单例对象  占用  资源 少，不需要  延时加载：
        枚举式   好于   饿汉式
    单例对象  占用  资源 大，需要 延时加载：
        静态内部类式   好于  懒汉式
##### 饿汉式实现（单例对象立即加载）

饿汉式单例模式代码中，static变量会在类装载时初始化，此时也不会涉及多个线程对象访问该对象的问题。
虚拟机保证只会装载一次该类，肯定不会发生并发访问的问题。因此，可以省略synchronized关键字。

问题：如果只是加载本类，而不是要调用getInstance()，甚至永远没有调用，则会造成资源浪费！

##### 懒汉式实现（单例对象延迟加载）
要点：
    lazy load!                延迟加载，  懒加载！  真正用的时候才加载！
问题：
    资源利用率高了。但是，每次调用getInstance()方法都要同步，并发效率较低。

##### 双重检测锁实现

这个模式将同步内容下方到if内部，提高了执行的效率,不必每次获取对象时都进行同步，只有第一次才同步,创建了以后就没必要了。

问题：由于编译器优化原因和JVM底层内部模型原因，偶尔会出问题。不建议使用。


##### 静态内部类实现方式(也是一种懒加载方式)
要点：
    外部类没有static属性，则不会像饿汉式那样立即加载对象。
    只有真正调用getInstance(),才会加载静态内部类。加载类时是线程 安全的。 instance是static final类型，保证了内存中只有这样一个实例存在，而且只能被赋值一次，从而保证了线程安全性.
    兼备了并发高效调用和延迟加载的优势！

问题：
    反射可以破解上面几种(不包含枚举式)实现方式！（可以在构造方法中手动抛出异常控制）
    反序列化可以破解上面几种((不包含枚举式))实现方式！
        可以通过定义readResolve()防止获得不同对象。
        反序列化时，如果对象所在类定义了readResolve()，（实际是一种回调），定义返回哪个对象。

##### 使用枚举实现单例模式
优点：
    实现简单
    枚举本身就是单例模式。由JVM从根本上提供保障！避免通过反射和反序列化的漏洞！

缺点：无延迟加载

##### 常见的五种单例模式在多线程环境下的效率测试

大家只要关注相对值即可。在不同的环境下不同的程序测得值完全不一样
    饿汉式	22ms
    懒汉式	636ms
    静态内部类式	28ms
    枚举式	32ms
    双重检查锁式	65ms

CountDownLatch 同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。
    countDown()  当前线程调此方法，则计数减一(建议放在 finally里执行)
    await()，   调用此方法会一直阻塞当前线程，直到计时器的值为0

### 工厂模式
工厂模式：
    实现了创建者和调用者的分离。
详细分类：
    简单工厂模式
    工厂方法模式
    抽象工厂模式

#### 面向对象设计的基本原则：
    OCP（开闭原则，Open-Closed Principle）：一个软件的实体应当对扩展开放，对修改关闭。
    DIP（依赖倒转原则，Dependence Inversion Principle）：要针对接口编程，不要针对实现编程。
    LoD（迪米特法则，Law of Demeter）：只与你直接的朋友通信，而避免和陌生人通信。

#### 核心本质：
    实例化对象，用工厂方法代替new操作。
    将选择实现类、创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。

#### 工厂模式要点：
    简单工厂模式
        用来生产同一等级结构中的任意产品。（对于增加新的产品，需要修改已有代码）
        虽然某种程度不符合设计原则，但实际使用最多。
    工厂方法模式
        用来生产同一等级结构中的固定产品。（支持增加任意产品）   
        不修改已有类的前提下，通过增加新的工厂类实现扩展。
    抽象工厂模式
        用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族） 
        不可以增加产品，可以增加产品族！

#### 应用场景
    JDK中Calendar的getInstance方法
    JDBC中Connection对象的获取
    Hibernate中SessionFactory创建Session
    spring中IOC容器创建管理bean对象
    XML解析时的DocumentBuilderFactory创建解析器对象
    反射中Class对象的newInstance()


##### 简单工厂模式
要点：
    简单工厂模式也叫静态工厂模式，就是工厂类一般是使用静态方法，通过接收的参数的不同来返回不同的对象实例。
    对于增加新产品无能为力！不修改代码的话，是无法扩展的。

##### 工厂方法模式要点：
    为了避免简单工厂模式的缺点，不完全满足OCP。
    工厂方法模式和简单工厂模式最大的不同在于，简单工厂模式只有一个（对于一个项目或者一个独立模块而言）工厂类，而工厂方法模式有一组实现了相同接口的工厂类。

##### 简单工厂模式和工厂方法模式PK:
    结构复杂度
        从这个角度比较，显然简单工厂模式要占优。简单工厂模式只需一个工厂类，而工厂方法模式的工厂类随着产品类个数增加而增加，这无疑会使类的个数越来越多，从而增加了结构的复杂程度。
    代码复杂度
        代码复杂度和结构复杂度是一对矛盾，既然简单工厂模式在结构方面相对简洁，那么它在代码方面肯定是比工厂方法模式复杂的了。简单工厂模式的工厂类随着产品类的增加需要增加很多方法（或代码），而工厂方法模式每个具体工厂类只完成单一任务，代码简洁。
    客户端编程难度
        工厂方法模式虽然在工厂类结构中引入了接口从而满足了OCP，但是在客户端编码中需要对工厂类进行实例化。而简单工厂模式的工厂类是个静态类，在客户端无需实例化，这无疑是个吸引人的优点。
    管理上的难度
        这是个关键的问题。
        我们先谈扩展。众所周知，工厂方法模式完全满足OCP，即它有非常良好的扩展性。那是否就说明了简单工厂模式就没有扩展性呢？答案是否定的。简单工厂模式同样具备良好的扩展性——扩展的时候仅需要修改少量的代码（修改工厂类的代码）就可以满足扩展性的要求了。尽管这没有完全满足OCP，但我们不需要太拘泥于设计理论，要知道，sun提供的java官方工具包中也有想到多没有满足OCP的例子啊。
        然后我们从维护性的角度分析下。假如某个具体产品类需要进行一定的修改，很可能需要修改对应的工厂类。当同时需要修改多个产品类的时候，对工厂类的修改会变得相当麻烦（对号入座已经是个问题了）。反而简单工厂没有这些麻烦，当多个产品类需要修改是，简单工厂模式仍然仅仅需要修改唯一的工厂类（无论怎样都能改到满足要求吧？大不了把这个类重写）。
    根据设计理论建议：工厂方法模式。但实际上，我们一般都用简单工厂模式。

##### 抽象工厂模式
    用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族） 
    抽象工厂模式是工厂方法模式的升级版本，在有多个业务品种、业务分类时，通过抽象工厂模式产生需要的对象是一种非常好的解决方式。






