# Head First Python
## 引子
你的大脑与Python
### 谁适合看这本书？
### 我们知道你在想什么
### 我们也知道你的大脑正在想什么
### 元知识：有关思考的思考
### 我们是这么做的
### 重要说明
### 致谢
## 1 基础知识：快速入门
尽快开始Python编程
### 了解IDLE的窗口
### 执行代码，一次执行一条语句
### 函数 + 模块 = 标准库
### 数据结构是内建的
### 调用方法包含结果
### 决定什么时候去年代码块
### 对应“if”可以有什么“else”？
### 代码组可以包含嵌套代码组
我们已经知道些什么
    Python提供了一个内置IDE，名为IDLE，允许创建、编辑和运行Python代码，你要做的就是输入代码、保存然后按F5运行。
    IDLE与Python解释器交互，解释器会为你自动完成编译——>链接——>运行过程，这使你能够集中精力编写你的代码。
    解释器从上到下运行（存储在一个文件中的）代码，一次执行一行。Python中没有main()函数/方法的概念。
    Python提供了一个强大的标准库，允许你访问大量可重用的模块（datetime只是其中一个例子）。
    编写Python程序时，可以使用一组标准数据结构。列表是其中之一，这与数组的概念很类似。
    不需要声明一个变量的类型，在Python中为一个变量赋值时，它会自动取相应数据的类型。
    可以在if/elif/else语句完成判定，if,elif和else关键字放在代码块前面，在Python中代码块称为“代码组”。
    代码组很容易发现，因为它们总是缩进的，缩进是Python提供的唯一的代码分组机制。
    除了缩进，代码组前面还可以有一个冒号(:)，这是Python语言的一个语法要求。
### 回到 Python Shell
### 在 Shell 上试验
### 迭代处理一个对象序列
### 迭代指定的次数
### 在代码中应用任务1的成果
### 让执行暂停
### 用Python 生成随机整数
### 编写一个正式的商店应用
### 缩进是不是让你抓狂？
### 向解释器请求一个函数的帮助文档
### Range 试验
### 第1章的代码
## 2 列表数据：处理有序数据
所有程序都会处理数据，Python程序也不例外
### 数字、字符串和对象
### 认识4个内置数据结构
### 无序数据结构：字典
### 一种避免重复的数据结构：集合
### 按字面创建列表
### 有多行代码时使用编辑器
### 在运行时“扩展”列表
### 用“in”检查成员关系
### 从列表删除对象
### 用对象扩展列表
### 在列表中插入一个对象
### 如何复制一个数据结构
### 列表扩展中括号记法
### 列表认识开始、结束和步长值
### 开始和结束列表
### 在列表中使用切片
### Python的"for"循环了解列表
### Marvin切片详解
### 什么时候不使用列表
### 第2章的代码
## 3 结构化数据：处理结构化数据
Python的列表数据结构很棒，不过它不是万能的
### 字典存储键/值对
### 如何发现代码中的字典
### 不会维持插入顺序
### 用中括号查找值
### 运行时处理字典
### 更新频度计数器
### 迭代处理字典
### 迭代处理键和值
### 用"items"迭代处理字典
### 字典有多动态？
### 避免运行时出现KetError
### 用"in"检查成员关系
### 使用前确保初始化
### 用"not in"替换"in"
### 使用"setdefault"方法
### 高效创建集合
### 充分利用集合方法
### 元组的意义
### 结合内置数据结构
### 访问一个复杂数据结构的数据
### 第3章的代码
## 4 代码重用：函数与模块
重用代码是构建一个可维护的系统的关键。
### 利用函数重用代码
### 引入函数
### 调用你的函数
### 函数可以接收参数
### 返回一个值
### 返回多个值
### 回忆内置数据结构
### 建立一个通用的函数
### 创建另一个函数
### 为参数指定默认值
### 位置赋值与关键字赋值
### 更新已经知道的函数知识
### 从命令行运行Python
### 创建必要的安装文件
### 创建发布文件
### 用"pip"安装包
### 展示按值调用语义
### 展示按引用调用语义
### 安装测试开发工具
### 我们的代码PEP 8兼容性如何？
### 理解错误消息
### 第4章的代码
## 5 构建一个Web应用：来真格的
现阶段你已经掌握了足够多的Python知识，可以放心地构建应用了。
### Python：你已经知道些什么
### 我们希望Web应用做什么？
### 安装Flask
### Flask如何工作？
### 第一次运行Flask Web应用
### 创建一个Flask Web应用对象
### 用URL修饰函数
### 运行Web应用的行为
### 为Web提供功能
### 构建HTML表单
### 模板与Web页面相关
### 从Flask呈现模板
### 显示Web应用的HTML表单
### 准备运行模板代码
### 了解HTTP状态码
### 处理提交的数据
### 改进编辑/停止/启动/测试循环
### 用Flask访问HTML表单数据
### 在Web应用中使用请求数据
### 结果生成为HTML
### 准备把你的Web应用部署到云
### 第5章的代码
## 6 存储和管理数据：数据放在哪里
迟早需要把你的数据安全地存储在某个地方。
### 用Web应用的数据做些什么
### Python支持打开、处理和关闭文件
### 从现有的文件读取数据
### 比”打开、处理、关闭“更好的”with“
### 通过你的Web应用查看日志
### 通过查看源代码检查原始数据
### 现在来转义（你的数据）
### 在Web应用中查看整个日志
### 记录特定的Web请求属性
### 记录单行分隔数据
### 从原始数据到可读的输出
### 有HTML生成可读的输出
### 在模板中嵌入显示逻辑
### 用Jinja2生成可读的输出
### Web应用代码的当前状态
### 关于数据的问题
### 第6章代码
## 7 使用数据库：具体使用Python的DB-API
把数据存储在关系数据库系统很方便
### 基于数据库的Web应用
### 任务1:安装MySQL服务器
### 引入Python的DB-API
### 任务2:为Python安装一个MySQL数据库的驱动程序
### 安装MySQL Connector/Python
### 任务3:创建Web应用的数据库和表
### 确定日志数据的结构
### 确认表可以存放数据
### 任务4:创建代码处理Web应用的数据库和表
### 存储数据只是问题的一半
### 如何最好地重用你的数据库代码？
### 考虑你想重用什么
### 那个Import呢？
### 你以前已经见过这个模式
### 坏消息并没有那么糟糕
### 第7章的代码
## 8 一点点类：抽象行为和状态
类允许把代码行为和状态打包在一起
### 挂接到"with"语句
### 面向对象入门
### 由类创建对象
### 对象共享行为，但不共享状态
### 用Cou ntFromBy做更多事情
### 调用方法：理解细节
### 为类增加方法
### “self”的重要性
### 处理作用域
### 属性名前加"self"
### 使用之前初始化（属性）值
### Dunder "init" 初始化属性
### 用Dunder "init" 初始化属性
### 理解CountFromBy的表示
### 定义CountFromBy的表示
### 为CountFromBy提供合理的默认值
### 类：我们知道些什么
### 第8章的代码
## 9 上下文管理协议：挂接Python的with语句
现在该将你所学派上用场了
### 要共享这个Web应用的数据库代码，哪种方法最好
### 用方法管理上下文
### 你已经见过上下文管理器的使用
### 创建一个新的上下文管理器类
### 用数据库配置初始化类
### 用Dunder "enter" 完成建立
### 用Dunder "exit" 完成清理
### 重新考虑你的Web应用代码
### 回忆 "log_request" 函数
### 修改 "log_request" 函数
### 回忆 "view_the_log" 函数
### 不只是代码改变
### 修改 "view_the_log" 函数
### 回答数据问题
### 第9章的代码
## 10 函数修饰符：包装函数
要增强你的代码，第9章的上下文管理协议并不是全部
### Web服务器（而不是你的计算机）运行代码
### Flask的会话技术增加状态
### 字典查找获取状态
### 用会话管理登录
### 完成注销和状态检查
### 向函数传递一个函数
### 调用传入的函数
### 接收一个参数列表
### 处理参数字典
### 接收任意数量和类型的函数参数
### 创建函数修饰符
### 最后一步：处理参数
### 使用修饰符
### 再来限制对/viewlog的访问
### 第10章的代码
## 11 异常处理：出问题了怎么办
问题总有可能发生，不论你的代码有多好
### 数据库并不总是可用
### Web攻击是个棘手的问题
### 输入输出（有时）很慢
### 函数调用可能失败
### 用try执行容易出错的代码
### try一次，except多次
### 捕获所有异常的异常处理器
### 从”sys“了解异常
### 再来看捕获所有异常的异常处理器
### 回到我们的Web应用代码
### 安静地处理异常
### 处理其他数据库错误
### 避免紧耦合的代码
### 再看DBcm模块
### 创建定制异常
### ”DBcm“还会有什么问题？
### 处理SQLError有所不同
### 产生一个SQLError
### 简要回顾：增加健壮性
### 如何处理待会？这要看具体情况……
### 第11章的代码
## 11 3/4 关于线程：处理等待
你的代码有时要花很长时间执行
### 等待：怎么办？
### 如何查询数据库
### 数据库INSTERT和SELECT是不同的
### 一次完成多个工作
### 别郁闷：使用线程
### 最重要的是：不要惊慌
### 别郁闷：Flask能帮忙
### 现在这个Web应用健壮吗？
### 第11 3/4章的代码
## 12 高级迭代：疯狂地循环
我们的程序往往会在循环上花大量时间
### CSV数据读取为列表
### CSV数据读取为字典
### 去除空白符然后分解原始数据
### 串链方法调用时要当心
### 将数据转换为你需要的格式
### 转换为列表字典
### 发现列表的模式
### 将模式转换为推导式
### 仔细研究推导式
### 指定一个字典推导式
### 用过滤扩展推导式
### 用Python的方式处理复杂性
### 集合推导式的实际使用
### 关于”元组推导式“?
### 代码周围加小括号 == 生成器
### 使用列表推导式处理URL
### 使用生成器处理URL
### 定义你的函数要做什么
### 生成器函数中使用yield
### 跟踪生成器函数
### 最后一个问题
### 第12章的代码
## 附录A安装：安装Python
首要的事情：在你的计算机上安装Python
## 附录B Pythonanywhere：部署你的Web应用
在第5章的最后，我们说过只需要10分钟就可以把你的Web应用部署到云
## 附录C我们没有介绍的十大内容：还有更多需要学习
### 1.关于Python 2？
### 2.虚拟编程环境
### 3.关于面向对象的更多内容
### 4.字符串的格式
### 5.排序
### 6.更多标准库特性
### 7.并发运行你的代码
### 8.Tkinter提供GUI（以及使用Turtles）
### 9.测试之前不会结束
### 10.调试，调试，再调试
## 附录D我们没有介绍的十大项目：更多工具、库和模块
### 1.>>>的替代工具
### 2.IDLE的替代工具
### 3.Jupyter Notebook：基于Web的IDE
### 4.关于数据科学
### 5.Web开发技术
### 6.处理Web数据
### 7.更多数据源
### 8.编程工具
### 9.Kivy：我们见过的”最酷的项目“
### 10.替代实现
## 附录E多参与：Python社区
Python不只是一个很好的编程语言
## 索引


# 【尚学堂·百战程序员】
程序员修炼手册
一：学会观察这个世界
二：学会学习，再去学习
    守
        刚开始学习，首先要做到对老师和知识的“敬畏之心”。学习就要先信服老师，不服老师就别学。
        守”就是一心遵守老师的教诲，守住招式，反复练习.这 才 是最基本、也是最重要的阶段。
    破
        在试错过程中发挥自己的独创。开始“突破”老师的教诲，开始有自己的思考。
    离
        离”就是通过不断的思考和反复的练习，一点点“破”，最后形成了自己的风格。“脱离”老师开始讲的“招式”，升华成为“专家”。
三：要动手，实战吧
    无论如何，请坚持不懈的动手实战！
    不管是 学习编程， 还是 学习 其他 任何技术，一定要动手，仅仅靠看和听是学不好编程的。
四：建立体系为先，不纠结，不事事求完美
    对待人生的任何事情都要：抓大放小，要事为先。
    任何事情都要追求完美才敢继续往后进行，是一种性格缺陷。大胆的放弃一些东西吧，有失才有得，把自己有限的、宝贵的精力用在对于就业直接相关的地方，这才是最有效率的学习方式！ 
五：什么是高手
    想成为高手，先建立“知识体系”，再根据需要去钻研某些细节。
    当你看书到某个地方暂时不理解的时候，暂时放手吧，追求一些行云流水、自然而然的境界吧，只是不要停下前进的脚步，不要被大路旁边的支根末节干扰了你前进的行程，项目，真实的项目，这才是目的。
六：问题解决之道（会提问、会搜索）
    1、要仔细观察错误的现象。不要随便问人
    2、仔细思考问题会出在哪些环境（重要）
    3、如何定位错误（重要） 分析清楚有哪些环境之后，下一步就是定位到底什么环境出错了。
    4、如果还不行，搜索吧
        先精后粗，首先先尽量精确的查找 。
    5、什么？还不行？那么就BBS和QQ群吧
七：项目的自学

培训四个作用是自学无法满足的：
    A：系统化知识
    B：真实项目锻炼经验
    C：少走弯路，节省时间
    D: 形成师生朋友圈

# 【尚学堂·百战程序员】python400集
## Python入门
### 第一个Python程序中需要注意的小要点：
   1、不要在程序中，行开头处增加空格，空格在Python中有缩进的含义。
   2、符号都是英文符号，不是中文。比如（“


### 程序基本格式
 1、恰当的空格，缩进问题
    (1)、逻辑行首的空白（空格和制表符）用来决定逻辑行首的缩进层次，从而用来决定语句的分组
    （2）、语句从新行的第一列开始。
    （3）、缩进风格统一：
        a、每个缩进层次全程，单个制表符或四个空格（IDE会自动将制表符设置成4个空格）
        b、Python用缩进而不是{}表示程序块
2、Python区分大小写
3、注释
    （1）、行注释
        每行注释前加#号。当解释器看到#,则忽略这一行#后面的内容
    （2）、段注释
        使用三个连续单引号（'''）。当解释器看到'''时，则会扫描到下一个‘’‘，然后忽略他们之间的内容

开始学习图形化程序设计

## 内置数据类型
### Python程序的构成
1、Python程序同模块组成。一个模块对应Python源文件，一般后缀名是：.py
2、模块由语句组成。运行Python程序时，按照模块中的语句的顺序依次执行。
3、语句是Python程序的构造单元，用于创建对象、变量赋值、调用函数、控制语句等。

#### 代码的组织和缩进
#### 使用注释#
#### 使用\行连接符

### 对象
Python中，一切皆对象。每个对象由：标识(identity)、类型(type)、值(value)组成。
    1、标识用于唯一标识对象，通常对应于对象在计算机内存中的地址。使用内置函数id(obj)可返回对象obj的标识
    2、类型用于表示对象存储的“数据“的类型。类型可以限制对象的取值范围以及要执行的操作。可以使用type(obj)获得对象的所属类型。
    3、值表示对象所存储的数据的信息。使用print(obj)可以直接打印出值。
对象的本质就是：一个内存块，拥有特定的值，支持特定类型的相关操作。

### 引用
在Python中，变量也成为：对象的引用。因为变量存储的就是对象的地址。
变量通过地址引用了”对象“。
变量位于：栈内存。
对象位于：堆内存。
Python是动态类型语言
变量不需要显式的声明类型。根据变量引用的对象，Python解释器自动确定数据类型。
Python是强类型语言
每个对象都有数据类型，只支持该类型支持的操作。

### 标识符
基本用法
标识符：用于变量、函数、类、模块等的名称。标识符有如下特定的规则
1、区分大小写。
2、第一个字符必须是字母、下划线。其后的字符是：字母、数字、下划线
3、不能使用关键字。
4、以双开线开头和结尾的名称通常有特殊含义

#### Python标识符命名规则
类型    规则    
模块和包名  全小写字母，尽量简单。苦多个单词之间用下划线
函数名      全小写字母，多个单词之间用下划线隔开
类名        首字母大写，采用驼峰原则。多个单词时，每个单词第一个字母大写，其余部分小写
常量名      全大写字母，多个单词用下划线隔开

#### 变量和简单赋值语句
变量的声明和赋值
变量名 = 表达式
变量在使用前必须先被初始化（先被赋值）

#### 删除变量和垃圾回收机制
可以使用del语句删除不再使用的变量。
如果对象没有变量引用，就会被垃圾回收器回收，清空内存空间。

#### 链式赋值
用于同一个对象赋值给多个变量

#### 系列解包赋值
系列数据赋值给对应相同个数的变量（个数必须保持一致）
a,b,c=4,5,6 相当于：a=4;b=5;c=6
a,b=b,a

#### 常量
Python不支持常量，即没有语法规则限制改变一个常量的值。

### 最基本内置数据类型
1、整形
    整数
2、浮点型
    小数
3、布尔型
    表示真假
4、字符串型
    由字符组成的序列。

#### 数字
Python支持整数和浮点数，
运算符  说明        示例    结果
+       加法        3+2     5
-       减法        30-5    25
*       乘法        3*6     18
/       浮点数除法   7/2     3.5
//      整数除法    7//2    3
%       模(取余)    7%4     3
**      幂          2**3    8

除数为0，会产生异常
使用divmod()函数同时得到商和余数.返回一个元组。
>>> divmod(13,3)
(4,1)

#### 整数
Python中，除10进制，还有其它三种进制：
0b或0B，二进制  0   1
0o或0O，八进行  0   1   2   3   4   5   6   7
0x或0X，十六进制 0 1 2 3 4 5 6 7 8 9 a b c d e f

#### 使用int()实现类型转换
1、浮点数直接舍去小数部分。
2、布尔值True转为1，False转为0.
3、字符串符合整数格式（浮点数格式不行）则直接转成对应整数，否则报错。

自动转型
整数和浮点数混合运算时，表达式结果自动转型成浮点数。

#### 整数可以有多大？
Python2中，int是32位。Long是64位。
Python3中，int可以存储任意大小的整数，long被取消。

### 浮点数
浮点数，称为float，用科学计数法表示。
在内存中也是按照科学计数法存储。

#### 类型转换和四舍五入
1.  float()
2.
3. round(value)可以返回四舍五入的值
注：但不会改变原有值，而是产生新的值

#### 增强型赋值运算符
运算符+、-、*、/、//、**、% 和赋值符=结合可以构成增强型赋值运算符
增强型赋值运算符中间不能加空格

#### 时间的表示
计算机中时间的表示是从“1970年1月1日 00:00:00”开始，以毫秒进行计算。这个时间称为“unix时间点”。
python中可以通过time.time()获得当前时刻，返回的值是以秒为单位，带微秒(1/1000毫秒)精度的浮点数值。

#### 定义多点坐标，给出折线，并计算距离

#### 布尔值
Python2中没有关键字，用数字0表示False，用数字1表示True
Python3中定义了关键字，但本质上还是数字0和1，可以和数字相加。

#### 比较运算符
==
!=
>
<
>=
<=

#### 逻辑运算符
运算符      格式    说明
or  逻辑或  x or y  x为true,则不计算y，直接返回true
and 逻辑与  x and y x为true,则返回y,x为true，
not 逻辑非  not x

#### 同一运算符
用于比较两个对象的存储单元，实际比较的是对象的地址。

is 与 == 区别：
is 用于判断两个变量引用对象是否为同一个，既比较对象的地址。
== 用于判断引用变量对象的值是否相等，默认调用对象的__eq__()方法。
is 运算符比 == 效率高，在变量和None进行比较时，应该使用 is。

整数缓存问题
Python仅仅对比较小的整数对象进行缓存(范围为[-5,256])缓存起来，以供重复使用，而并非所有整数对象。
注意：这仅仅是在命令行中执行，而保存文件执行，结果是不一样的，这是因为解释器做了一部分优化（范围是[-5,任意正整数]）。

### 字符串
#### 字符串的基本特点
字符串的本质是：字符序列。Python中字符串是不可变的，我们无法对原字符串做任何修改。
Python不支持单字符类型，单字符也是作为一个字符串使用的。

#### 字符串的编码
Python3直接支持Unicode，可以表示任何书面语言的字符。Python3的字符默认就是16位Unicode编码，ASCII码是Unicode编码的子集。
使用内置函数ord()可以把字符转换成对应的Unicode码。
使用内置的chr()可以把十进行数字转换成字符。

#### 引号创建字符串
可以通过单引号和双引号创建字符串。

连续三个单引号或三个双引号，可以创建多行字符串。

#### 空字符串和len()函数
Python允许空字符串存在，不包含任何字符且长度为0.
len()用于计算字符串含有多少字符。

#### 转义字符
我们可以使用“\+特殊字符”，实现某些难以用字符表示的效果。
常见的转义字符有这些：
转义字符    描述
\(在行尾时) 续行符
\\          反斜杠符号
\'          单引号
\"          双引号
\b          退格(Backspace)
\n          换行
\t          横向制表符
\r          回车

#### 字符串拼接
1. 可以使用+将多个字符串拼接起来。例如：’aa’ + ’bb’ ==>’aabb’。
(1) 如果+两边都是字符串，则拼接。
(2) 如果+两边都是数字，则加法运算。
(3) 如果+两边类型不同，则抛出异常。
2. 可以将多个字面字符串直接放到一起实现拼接。例如：’aa’’bb’==>’aabb’

### 字符串复制
使用*可以实现字符串复制。
【操作】字符串复制操作
>>> a = 'Sxt'*3
>>> a
'SxtSxtSxt'

#### 不换行打印
我们前面调用 print 时，会自动打印一个换行符。有时，我们不想换行，不想自动添加换行
符。我们可以自己通过参数 end = “任意字符串”。实现末尾添加任何内容

#### 从控制台读取字符串
我们可以使用 input()从控制台读取键盘输入的内容

#### str()实现数字转型字符串
str()可以帮助我们将其他数据类型转换为字符串。
当我们调用 print()函数时，解释器自动调用了 str()将非字符串的对象转成了字符串。

#### 使用[]提取字符
字符串的本质就是字符序列，我们可以通过在字符串后面添加[]，在[]里面指定偏移量，可以提取该位置的单个字符。
正向搜索：
    最左侧第一个字符，偏移量是 0，第二个偏移量是 1，以此类推。直到 len(str)-1为止。
反向搜索：
    最右侧第一个字符，偏移量是-1，倒数第二个偏移量是-2，以此类推，直到-len(str)为止

#### replace()实现字符串替换
字符串是“不可改变”的，我们通过[]可以获取字符串指定位置的字符，但是我们不能改变字符串。
字符串不可改变。但是，我们确实有时候需要替换某些字符。这时，只能通过创建新的字符串来实现。
整个过程中，实际上我们是创建了新的字符串对象，并指向了变量 a，而不是修改了以前的字符串。 

#### 字符串切片 slice 操作
切片 slice 操作可以让我们快速的提取子字符串。标准格式为：
[起始偏移量 start：终止偏移量 end：步长 step]

典型操作(三个量为正数的情况)如下：
操作和说明                                          示例            结果
[:] 提取整个字符串                                  “abcdef”[:]     “abcdef”
[start:] 从 start 索引开始到结尾                    “abcdef”[2:]    “cdef”
[:end]  从头开始知道 end-1                          “abcdef”[:2]    “ab”
[start:end] 从 start 到 end-1                     “abcdef”[2:4]    “cd”
[start:end:step] 从 start 提取到end-1，步长是 step  “abcdef”[1:5:2]  “bd”

其他操作（三个量为负数）的情况：
示例                                说明                            结果
"abcdefghijklmnopqrstuvwxyz"[-3:]   倒数三个                        “xyz”
"abcdefghijklmnopqrstuvwxyz"[-8:-3] 倒数第八个到倒数第三个(包头不包尾)  'stuvw'
"abcdefghijklmnopqrstuvwxyz"[::-1]  步长为负，从右到左反向提取          'zyxwvutsrqponmlkjihgfedcba'

切片操作时，起始偏移量和终止偏移量不在[0,字符串长度-1]这个范围，也不会报错。起始
偏移量小于 0 则会当做 0，终止偏移量大于“长度-1”会被当成-1。

#### split()分割和 join()合并
split()可以基于指定分隔符将字符串分隔成多个子字符串(存储到列表中)。如果不指定分隔符，则默认使用空白字符(换行符/空格/制表符)。
join()的作用和 split()作用刚好相反，用于将一系列子字符串连接起来。
>>> a = ['sxt','sxt100','sxt200']
>>> '*'.join(a)
'sxt*sxt100*sxt200'

拼接字符串要点：
使用字符串拼接符+，会生成新的字符串对象，因此不推荐使用+来拼接字符串。推荐使用 join 函数，因为 join 函数在拼接字符串之前会计算所有字符串的长度，然后逐一拷贝，仅新建一次对象.

#### 字符串驻留机制和字符串比较
字符串驻留：仅保存一份相同且不可变字符串的方法，不同的值被存放在字符串驻留池中。
Python 支持字符串驻留机制，对于符合标识符规则的字符串（仅包含下划线（_）、字母
和数字）会启用字符串驻留机制驻留机制。

#### 字符串比较和同一性
我们可以直接使用==,!=对字符串进行比较，是否含有相同的字符。
我们使用 is / not is，判断两个对象是否同一个对象。比较的是对象的地址，即 id(obj1)是
否和 id(obj2)相等。 

#### 成员操作符
in /not in 关键字，判断某个字符(子字符串)是否存在于字符串中。 

#### 字符串常用方法汇总
方法和使用示例           说明               结果
len(a)                  符串长度            96
a.startswith('我是高淇') 以指定字符串开头    True
a.endswith('过我')       以指定字符串结尾    True
a.find('高')        第一次出现指定字符串的位置  2
a.rfind('高')       最后一次出现指定字符串的位置 29
a.count("编程")     指定字符串出现了几次         3
a.isalnum()         所有字符全是字母或数字      False

#### 去除首尾信息
我们可以通过 strip()去除字符串首尾指定信息。通过 lstrip()去除字符串左边指定信息，rstrip()去除字符串右边指定信息。

#### 大小写转换
编程中关于字符串大小写转换的情况，经常遇到。

示例 说明 结果
a.capitalize() 产生新的字符串,首字母大写    'Gaoqi love programming, love sxt' 
a.title() 产生新的字符串,每个单词都首字母大写   'Gaoqi Love Programming, Love Sxt' 
a.upper() 产生新的字符串,所有字符全转成大写 'GAOQI LOVE PROGRAMMING, LOVESXT' 
a.lower() 产生新的字符串,所有字符全转成小写 'gaoqi love programming, love sxt'  
a.swapcase() 产生新的,所有字母大小写转换    'GAOQI LOVE PROGRAMMING, LOVE sxt

#### 格式排版
center()、ljust()、rjust()这三个函数用于对字符串实现排版。示例如下：
>>> a="SXT" 
>>> a.center(10,"*")
'***SXT****' 
>>> a.center(10)
' SXT ' 
>>> a.ljust(10,"*")
'SXT*******'

#### 其他方法
1. isalnum() 是否为字母或数字
2. isalpha() 检测字符串是否只由字母组成(含汉字)。
3. isdigit() 检测字符串是否只由数字组成。
4. isspace() 检测是否为空白符
5. isupper() 是否为大写字母
6. islower() 是否为小写字母

#### 字符串的格式化
#### format()基本用法
Python2.6 开始，新增了一种格式化字符串的函数 str.format()，它增强了字符串格式化的功能。
基本语法是通过 {} 和 : 来代替以前的 % 。
format 函数可以接受不限个参数，位置可以不按顺序。

我们通过示例进行格式化的学习。
>>> a = "名字是:{0},年龄是：{1}" 
>>> a.format("高淇",18)
'名字是:高淇,年龄是：18' 
>>> a.format("高希希",6)
'名字是:高希希,年龄是：6' 
>>> b = "名字是：{0}，年龄是{1}。{0}是个好小伙" 
>>> b.format("高淇",18)
'名字是：高淇，年龄是 18。高淇是个好小伙' 
>>> c = "名字是{name}，年龄是{age}" 
>>> c.format(age=19,name='高淇')
'名字是高淇，年龄是 19' 

我们可以通过{索引}/{参数名}，直接映射参数值，实现对字符串的格式化，非常方便。

#### 填充与对齐
填充常跟对齐一起使用
^、<、>分别是居中、左对齐、右对齐，后面带宽度
:号后面带填充的字符，只能是一个字符，不指定的话默认是用空格填充

>>> "{:*>8}".format("245")
'*****245' 
>>> "我是{0},我喜欢数字{1:*^8}".format("高淇","666")
'我是高淇,我喜欢数字**666***'

#### 数字格式化
浮点数通过 f，整数通过 d 进行需要的格式化。案例如下：
>>> a = "我是{0}，我的存款有{1:.2f}" 
>>> a.format("高淇",3888.234342)
'我是高淇，我的存款有 3888.23'

其他格式，供大家参考：
数字        格式        输出    描述
3.1415926   {:.2f}      3.14    保留小数点后两位
3.1415926   {:+.2f}     3.14    带符号保留小数点后两位
2.71828     {:.0f}      3       不带小数
5           {:0>2d}     05      数字补零 (填充左边, 宽度为 2)
5           {:x<4d}     5xxx    数字补 x (填充右边, 宽度为 4)
10          {:x<4d}     10xx    数字补 x (填充右边, 宽度为 4)
1000000     {:,}        1,000,000   以逗号分隔的数字格式
0.25        {:.2%}      25.00%  百分比格式
1000000000  {:.2e}      1.00E+09   指数记法
13          {:10d}      13       右对齐 (默认, 宽度为 10)
13          {:<10d}     13      左对齐 (宽度为 10)
13          {:^10d}     13      中间对齐 (宽度为 10)

#### 可变字符串
在 Python 中，字符串属于不可变对象，不支持原地修改，如果需要修改其中的值，智能创建新的字符串对象。但是，经常我们确实需要原地修改字符串，可以使用 io.StringIO对象或 array 模块。

>>> import io
>>> s = "hello, sxt" >>> sio = io.StringIO(s)
>>> sio
<_io.StringIO object at 0x02F462B0>
>>> sio.getvalue()
'hello, sxt' 
>>> sio.seek(7)
7
>>> sio.write("g")
1
>>> sio.getvalue()
'hello, gxt'

#### 本章实操作业
1、(5+10*x)/5-13*(y-1)(a+b)/x+9(5/x+(12+x)/y)
2、mone = input()
print( mone * 12)
3、"爱你一百遍"*100
4、” to be ro not to be“[::-1]
5、" sxtsxtsxtsxtsxt"[1::3]
6、a is b True  a和b的值符合命名规则，可以驻留内存，是同一个对象
c is d False    c和d不可驻留内存，是不同的对象
7、”名字是高淇，年龄是19“

## 第 3 章 序列
序列是一种数据存储方式，用来存储一系列的数据。在内存中，序列就是一块用来存放多个值的连续的内存空间。

序列中存储的是整数对象的地址，而不是整数对象的值。python中常用的序列结构有：
字符串、列表、元组、字典、集合

我们上一章学习的字符串就是一种序列。关于字符串里面很多操作，在这一章中仍然会用到，

### 列表简介
列表：用于存储任意数目、任意类型的数据集合。
列表是内置可变序列，是包含多个元素的有序连续的内存空间。列表定义的标准语法格式：
a = [10,20,30,40]
其中，10,20,30,40 这些称为：列表 a 的元素。
列表中的元素可以各不相同，可以是任意类型。比如：
a = [10,20,'abc',True]
列表对象的常用方法汇总如下，方便大家学习和查阅。

方法                要点 描述
list.append(x)      增加元素    将元素 x 增加到列表 list 尾部
list.extend(aList)  增加元素    将列表 alist 所有元素加到列表 list 尾部
list.insert(index,x) 增加元素   在列表 list 指定位置 index 处插入元素 x
list.remove(x)      删除元素    在列表 list 中删除首次出现的指定元素 x
list.pop([index])   删除元素    删除并返回列表 list 指定为止 index 处的元素，默认是最后一个元素
list.clear()        删除所有元素 删除列表所有元素，并不是删除列表对象
list.index(x)       访问元素    返回第一个 x 的索引位置，若不存在 x 元素抛出异常
list.count(x)       计数        返回指定元素 x 在列表 list 中出现的次数
len(list)           列表长度    返回列表中包含元素的个数
list.reverse()      翻转列表    所有元素原地翻转
list.sort()         排序        所有元素原地排序
list.copy()         浅拷贝      返回列表对象的浅拷贝

Python 的列表大小可变，根据需要随时增加或缩小。
字符串和列表都是序列类型，一个字符串是一个字符序列，一个列表是任何元素的序列。我们前面学习的很多字符串的方法，在列表中也有类似的用法，几乎一模一样

### 列表的创建
####基本语法[]创建
>>> a = [10,20,'gaoqi','sxt']
>>> a = [] #创建一个空的列表对象

#### list()创建
使用 list()可以将任何可迭代的数据转化成列表。
>>> a = list() #创建一个空的列表对象
>>> a = list(range(10))
>>> a
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> a = list("gaoqi,sxt")
>>> a
['g', 'a', 'o', 'q', 'i', ',', 's', 'x', 't']

#### range()创建整数列表
range()可以帮助我们非常方便的创建整数列表，这在开发中及其有用。语法格式为：
range([start,] end [,step])
start 参数：可选，表示起始数字。默认是 0
end 参数：必选，表示结尾数字。
step 参数：可选，表示步长，默认为 1

python3 中 range()返回的是一个 range 对象，而不是列表。我们需要通过 list()方法将其转换成列表对象。

#### 推导式生成列表(简介一下，重点在 for 循环后讲)
使用列表推导式可以非常方便的创建列表，在开发中经常使用。但是，由于涉及到 for 循环和 if 语句。在此，仅做基本介绍。在我们控制语句后面，会详细讲解更多列表推导式的细节。
>>> a = [x*2 for x in range(5)] #循环创建多个元素
>>> a
[0, 2, 4, 6, 8]
>>> a = [x*2 for x in range(100) if x%9==0] #通过 if 过滤元素
>>> a
[0, 18, 36, 54, 72, 90, 108, 126, 144, 162, 180, 198]

### 列表元素的增加和删除
当列表增加和删除元素时，列表会自动进行内存管理，大大减少了程序员的负担。但这
个特点涉及列表元素的大量移动，效率较低。除非必要，我们一般只在列表的尾部添加元素
或删除元素，这会大大提高列表的操作效率。

#### append()方法
原地修改列表对象，是真正的列表尾部添加新的元素，速度最快，推荐使用。

#### +运算符操作
并不是真正的尾部添加元素，而是创建新的列表对象；将原列表的元素和新列表的元素依次复制到新的列表对象中。这样，会涉及大量的复制操作，对于操作大量元素不建议使用。

#### extend()方法
将目标列表的所有元素添加到本列表的尾部，属于原地操作，不创建新的列表对象

#### insert()插入元素
使用 insert()方法可以将指定的元素插入到列表对象的任意制定位置。
这样会让插入位置后面所有的元素进行移动，会影响处理速度。涉及大量元素时，尽量避免使用。
类似发生这种移动的函数还有：remove()、pop()、del()，它们在删除非尾部元素时也会发生操作位置后面元素的移动

#### 乘法扩展
使用乘法扩展列表，生成一个新列表，新列表元素时原列表元素的多次重复。
适用于乘法操作的，还有：字符串、元组。

### 列表元素的删除
#### del 删除
删除列表指定位置的元素。

#### pop()方法
pop()删除并返回指定位置元素，如果未指定位置则默认操作列表最后一个元素。

#### remove()方法
删除首次出现的指定元素，若不存在该元素抛出异常。

### 列表元素访问和计数
#### 通过索引直接访问元素
我们可以通过索引直接访问元素。索引的区间在[0, 列表长度-1]这个范围。超过这个范围则会抛出异常。

#### index()获得指定元素在列表中首次出现的索引
index()可以获取指定元素首次出现的索引位置。语法是：index(value,[start,[end]])。其中，start 和 end 指定了搜索的范围。

#### count()获得指定元素在列表中出现的次数
count()可以返回指定元素在列表中出现的次数。

#### len()返回列表长度
len()返回列表长度，即列表中包含元素的个数。

#### 成员资格判断
判断列表中是否存在指定的元素，我们可以使用 count()方法，返回 0 则表示不存在，返回大于 0 则表示存在。
但是，一般我们会使用更加简洁的 in 关键字来判断，直接返回 True或 False。

### 切片操作
我们在前面学习字符串时，学习过字符串的切片操作，对于列表的切片操作和字符串类似。
切片是 Python 序列及其重要的操作，适用于列表、元组、字符串等等。切片的格式如下：

切片 slice 操作可以让我们快速提取子列表或修改。标准格式为：
[起始偏移量 start:终止偏移量 end[:步长 step]]

注：当步长省略时顺便可以省略第二个冒号

典型操作(三个量为正数的情况)如下：

操作和说明 示例 结果
[:] 提取整个列表 [10,20,30][:] [10,20,30]
[start:]从 start 索引开始到结尾[10,20,30][1:] [20,30]
[:end]从头开始知道 end-1 [10,20,30][:2] [10,20]
[start:end]从 start 到 end-1 [10,20,30,40][1:3] [20,30]
[start:end:step] 从 start 提取到 end-1，步长是 step[10,20,30,40,50,60,70][1:6:2][20, 40, 60]

其他操作（三个量为负数）的情况：
示例 说明 结果
[10,20,30,40,50,60,70][-3:] 倒数三个 [50,60,70]
[10,20,30,40,50,60,70][-5:-3] 倒数第五个到倒数第三个(包头不包尾)[30,40]
[10,20,30,40,50,60,70][::-1] 步长为负，从右到左反向提取[70, 60, 50, 40, 30, 20, 10]

切片操作时，起始偏移量和终止偏移量不在[0,字符串长度-1]这个范围，也不会报错。
起始偏移量小于 0 则会当做 0，终止偏移量大于“长度-1”会被当成”长度-1”。

#### 列表的遍历
for obj in listObj:
print(obj)

#### 复制列表所有的元素到新列表对象
我们可以通过如下简单方式，实现列表元素内容的复制：
list1 = [30,40,50]
list2 = [] + list1
注：我们后面也会学习 copy 模块，使用浅复制或深复制实现我们的复制操作。

### 列表排序
#### 修改原列表，不建新列表的排序
>>> a.sort() #默认是升序排列
>>> a
[10, 20, 30, 40]
>>> a = [10,20,30,40]
>>> a.sort(reverse=True) #降序排列
>>> a
[40, 30, 20, 10]
>>> import random
>>> random.shuffle(a) #打乱顺序
>>> a
[20, 40, 30, 10]

#### 建新列表的排序
我们也可以通过内置函数 sorted()进行排序，这个方法返回新列表，不对原列表做修改。
>>> a = sorted(a) #默认升序
>>> a
[10, 20, 30, 40]
>>> c = sorted(a,reverse=True) #降序
>>> c
[40, 30, 20, 10]

#### reversed()返回迭代器
内置函数 reversed()也支持进行逆序排列，与列表对象 reverse()方法不同的是，内置函数reversed()不对原列表做任何修改，只是返回一个逆序排列的迭代器对象。

我们打印输出 c 发现提示是：list_reverseiterator。也就是一个迭代对象。同时，我们使用
list(c)进行输出，发现只能使用一次。第一次输出了元素，第二次为空。那是因为迭代对象
在第一次时已经遍历结束了，第二次不能再使用。
注：关于迭代对象的使用，后续章节会进行详细讲解。

### 列表相关的其他内置函数汇总
#### max 和 min
用于返回列表中最大和最小值。

#### sum
对数值型列表的所有元素进行求和操作，对非数值型列表运算则会报错。

### 多维列表
#### 二维列表
一维列表可以帮助我们存储一维、线性的数据。
二维列表可以帮助我们存储二维、表格的数据。

### 元组 tuple
列表属于可变序列，可以任意修改列表中的元素。元组属于不可变序列，不能修改元组中的元素。
因此，元组没有增加元素、修改元素、删除元素相关的方法。
因此，我们只需要学习元组的创建和删除，元组中元素的访问和计数即可。元组支持如下操作：
1. 索引访问
2. 切片操作
3. 连接操作
4. 成员关系操作
5. 比较运算操作
6. 计数：元组长度 len()、最大值 max()、最小值 min()、求和 sum()等。

#### 元组的创建
##### 1. 通过()创建元组。小括号可以省略。
a = (10,20,30) 或者 a = 10,20,30
如果元组只有一个元素，则必须后面加逗号。这是因为解释器会把(1)解释为整数 1，(1,)解释为元组。

##### 2. 通过 tuple()创建元组
tuple(可迭代的对象)

总结：
tuple()可以接收列表、字符串、其他序列类型、迭代器等生成元组。
list()可以接收元组、字符串、其他序列类型、迭代器等生成列表。

#### 元组的元素访问和计数
1. 元组的元素不能修改
2. 元组的元素访问和列表一样，只不过返回的仍然是元组对象
3. 列表关于排序的方法 list.sorted()是修改原列表对象，元组没有该方法。
    如果要对元组排序，只能使用内置函数 sorted(tupleObj)，并生成新的列表对象。

#### zip
zip(列表 1，列表 2，...)将多个列表对应位置的元素组合成为元组，并返回这个 zip 对象。

#### 生成器推导式创建元组
从形式上看，生成器推导式与列表推导式类似，只是生成器推导式使用小括号。
列表推导式直接生成列表对象，生成器推导式生成的不是列表也不是元组，而是一个生成器对象。
我们可以通过生成器对象，转化成列表或者元组。也可以使用生成器对象的__next__()方法进行遍历，或者直接作为迭代器对象来使用。
不管什么方式使用，元素访问结束后，如果需要重新访问其中的元素，必须重新创建该生成器对象

#### 元组总结
1. 元组的核心特点是：不可变序列。
2. 元组的访问和处理速度比列表快。
3. 与整数和字符串一样，元组可以作为字典的键，列表则永远不能作为字典的键使用。

### 字典介绍
字典是“键值对”的无序可变序列，字典中的每个元素都是一个“键值对”，包含：“键对象”和“值对象”。
可以通过“键对象”实现快速获取、删除、更新对应的“值对象”。列表中我们通过“下标数字”找到对应的对象。字典中通过“键对象”找到对应的“值对象”。
“键”是任意的不可变数据，比如：整数、浮点数、字符串、元组。但是：列表、字典、集合这些可变对象，不能作为“键”。
并且“键”不可重复。“值”可以是任意的数据，并且可重复。

一个典型的字典的定义方式：
a = {'name':'gaoqi','age':18,'job':'programmer'}

#### 字典的创建
1. 我们可以通过{}、dict()来创建字典对象。
>>> a = {'name':'gaoqi','age':18,'job':'programmer'}
>>> b = dict(name='gaoqi',age=18,job='programmer')
>>> a = dict([("name","gaoqi"),("age",18)])

2. 通过 zip()创建字典对象
>>> k = ['name','age','job']
>>> v = ['gaoqi',18,'techer']
>>> d = dict(zip(k,v))

3. 通过 fromkeys 创建值为空的字典
>>> a = dict.fromkeys(['name','age','job'])

### 字典元素的访问
1. 通过 [键] 获得“值”。若键不存在，则抛出异常。

2. 通过 get()方法获得“值”。推荐使用。
优点是：指定键不存在，返回 None；也可以设定指定键不存在时默认返回的对象。推荐使用 get()获取“值对象”。

3. 列出所有的键值对
>>> a.items()
dict_items([('name', 'gaoqi'), ('age', 18), ('job', 'programmer')])

4. 列出所有的键，列出所有的值
>>> a.keys()
dict_keys(['name', 'age', 'job'])
>>> a.values()
dict_values(['gaoqi', 18, 'programmer'])

5. len() 键值对的个数

6. 检测一个“键”是否在字典中 in

### 字典元素添加、修改、删除
1. 给字典新增“键值对”。如果“键”已经存在，则覆盖旧的键值对；如果“键”不存在，则新增“键值对”。

2. 使用 update()将新字典中所有键值对全部添加到旧字典对象上。如果 key 有重复，则直接覆盖。

3. 字典中元素的删除，可以使用 del()方法；或者 clear()删除所有键值对；pop()删除指定键值对，并返回对应的“值对象”；

4. popitem() ：随机删除和返回该键值对。
字典是“无序可变序列”，因此没有第一个元素、最后一个元素的概念；
popitem 弹出随机的项，因为字典并没有"最后的元素"或者其他有关顺序的概念。
若想一个接一个地移除并处理项，这个方法就非常有效（因为不用首先获取键的列表）。

#### 序列解包
序列解包可以用于元组、列表、字典。序列解包可以让我们方便的对多个变量赋值。
>>> (a,b,c)=(9,8,10)
>>> [a,b,c]=[10,20,30]

序列解包用于字典时，默认是对“键”进行操作； 如果需要对键值对操作，则需要使用items()；如果需要对“值”进行操作，则需要使用 values()；

### 字典核心底层原理(重要)
字典对象的核心是散列表。散列表是一个稀疏数组（总是有空白元素的数组），数组的每个单元叫做 bucket。每个 bucket 有两部分：一个是键对象的引用，一个是值对象的引用。
由于，所有 bucket 结构和大小一致，我们可以通过偏移量来读取指定 bucket。

#### 将一个键值对放进字典的底层过程
假设字典 a 对象创建完后，数组长度为 8：
我们要把”name”=”gaoqi”这个键值对放到字典对象 a 中，首先第一步需要计算键”name”的散列值。Python 中可以通过 hash()来计算。
>>> bin(hash("name"))
'-0b1010111101001110110101100100101'
由于数组长度为 8，我们可以拿计算出的散列值的最右边 3 位数字作为偏移量，即“101”，十进制是数字 5。我们查看偏移量 5，对应的 bucket 是否为空。如果为空，则将键值对放进去。如果不为空，则依次取右边 3 位作为偏移量，即“100”，十进制是数字4。再查看偏移量为 4 的 bucket 是否为空。直到找到为空的 bucket 将键值对放进去。流程图如下：

扩容
python 会根据散列表的拥挤程度扩容。“扩容”指的是:创造更大的数组，将原有内容
拷贝到新数组中。
接近 2/3 时，数组就会扩容。

#### 根据键查找“键值对”的底层过程
当我们调用 a.get(“name”)，就是根据键“name”查找到“键值对”，从而找到值对象“gaoqi”。
第一步，我们仍然要计算“name”对象的散列值：
>>> bin(hash("name"))
'-0b1010111101001110110101100100101'

和存储的底层流程算法一致，也是依次取散列值的不同位置的数字。 假设数组长度为8，我们可以拿计算出的散列值的最右边 3 位数字作为偏移量，即“101”，十进制是数字5。我们查看偏移量 5，对应的 bucket 是否为空。如果为空，则返回 None。如果不为空，则将这个 bucket 的键对象计算对应散列值，和我们的散列值进行比较，如果相等。则将对应“值对象”返回。如果不相等，则再依次取其他几位数字，重新计算偏移量。依次取完后，仍然没有找到。则返回 None。流程图如下：

用法总结：
1. 键必须可散列
    (1) 数字、字符串、元组，都是可散列的。
    (2) 自定义对象需要支持下面三点：
        1 支持 hash()函数
        2 支持通过__eq__()方法检测相等性。
        3 若 a==b 为真，则 hash(a)==hash(b)也为真。
2. 字典在内存中开销巨大，典型的空间换时间。
3. 键查询速度很快
4. 往字典里面添加新建可能导致扩容，导致散列表中键的次序变化。因此，不要在遍历字典的同时进行字典的修改。

### 集合
集合是无序可变，元素不能重复。实际上，集合底层是字典实现，集合的所有元素都是字典中的“键对象”，因此是不能重复的且唯一的。

#### 集合创建和删除
1. 使用{}创建集合对象，并使用 add()方法添加元素
>>> a = {3,5,7}

2. 使用 set()，将列表、元组等可迭代对象转成集合。如果原来数据存在重复数据，则只保留一个。
>>> a = ['a','b','c','b']

3. remove()删除指定元素；clear()清空整个集合

#### 集合相关操作
像数学中概念一样，Python 对集合也提供了并集、交集、差集等运算。我们给出示例：
>>> a = {1,3,'sxt'}
>>> b = {'he','it','sxt'}
>>> a|b #并集
{1, 3, 'sxt', 'he', 'it'}
>>> a&b #交集
{'sxt'}
>>> a-b #差集
{1, 3}
>>> a.union(b) #并集
{1, 3, 'sxt', 'he', 'it'}
>>> a.intersection(b) #交集
{'sxt'}
>>> a.difference(b) #差集
{1, 3}

### 章节实操作业
1、
2、list(range(30,81,10))
3、
4、a = [["高小一",18,30000,"北京"],
    ["高小二",19,20000,"上海"],
    ["高小三", 20 , 10000 , "深圳"]]
5、
6、dict("支出金额":"300.15"，”支出日期“:"2018.10.18","支出人":"高淇")
7、


## 选择结构
选择结构通过判断条件是否成立，来决定执行哪个分支。选择结构有多种形式，分为：单分支、双分支、多分支。流程图如下：

### 单分支选择结构
if 语句单分支结构的语法形式如下：
if 条件表达式:
    语句/语句块

其中：
1 ．条件表达式：可以是逻辑表达式、关系表达式、算术表达式等等。
2 ．语句/语句块：可以是一条语句，也可以是多条语句。多条语句，缩进必须对齐一致。

#### 条件表达式详解
在选择和循环结构中，条件表达式的值为 False 的情况如下：
    False、0、0.0、空值 None、空序列对象（空列表、空元祖、空集合、空字典、空字符串）、空 range 对象、空迭代对象。

其他情况，均为 True。这么看来，Python 所有的合法表达式都可以看做条件表达式，甚至包括函数调用的表达式。

条件表达式中，不能有赋值操作符“=”
在 Python 中，条件表达式不能出现赋值操作符“=”，避免了其他语言中经常误将关系运算符“==”写作赋值运算符“=”带来的困扰。如下代码将会报语法错误：

### 双分支选择结构
双分支结构的语法格式如下：
if 条件表达式 :
    语句 1/语句块 1
else:
    语句 2/语句块 2

#### 三元条件运算符
Python 提供了三元运算符，用来在某些简单双分支赋值情况。三元条件运算符语法格式如下：
    条件为真时的值 if (条件表达式) else 条件为假时的值

### 多分支选择结构
多分支选择结构的语法格式如下：
if 条件表达式 1 :
    语句 1/语句块 1
elif 条件表达式 2:
    语句 2/语句块 2
.
.
.
elif 条件表达式 n :
    语句 n/语句块 n
[else:
    语句 n+1/语句块 n+1
]
【注】计算机行业，描述语法格式时，使用中括号[]通常表示可选，非必选。

多分支结构，几个分支之间是有逻辑关系的，不能随意颠倒顺序。

### 选择结构嵌套
选择结构可以嵌套，使用时一定要注意控制好不同级别代码块的缩进量，因为缩进量决定了
代码的从属关系。语法格式如下：
if 表达式 1：
    语句块 1
    if 表达式 2：
        语句块 2
    else:
        语句块 3
else:
    if 表达式 4：
        语句块 4

## 循环结构
循环结构用来重复执行一条或多条语句。表达这样的逻辑：如果符合条件，则反复执行循环体里的语句。
在每次执行完后都会判断一次条件是否为 True，如果为 True 则重复执行循环体里的语句。图示如下：

循环体里面的语句至少应该包含改变条件表达式的语句，以使循环趋于结束；否则，就会变成一个死循环。

### while 循环
while 循环的语法格式如下：
while 条件表达式：
    循环体语句

### for 循环和可迭代对象遍历
for 循环通常用于可迭代对象的遍历。for 循环的语法格式如下：
for 变量 in 可迭代对象：
    循环体语句

#### 可迭代对象
Python 包含以下几种可迭代对象：
1. 序列。包含：字符串、列表、元组
2. 字典
3. 迭代器对象（iterator）
4. 生成器函数（generator）
5. 文件对象

#### range 对象
range 对象是一个迭代器对象，用来产生指定范围的数字序列。格式为：
range(start, end [,step])
生成的数值序列从 start 开始到 end 结束（不包含 end）。若没有填写 start，则默认从 0开始。step 是可选的步长，默认为 1。
如下是几种典型示例：
for i in range(10) 产生序列：0 1 2 3 4 5 6 7 8 9
for i in range(3,10) 产生序列：3 4 5 6 7 8 9
for i in range(3,10,2) 产生序列：3 5 7 9

#### 嵌套循环和综合练习
一个循环体内可以嵌入另一个循环，一般称为“嵌套循环”，或者“多重循环”。

#### break 语句
break 语句可用于 while 和 for 循环，用来结束整个循环。当有嵌套循环时，break 语句只能跳出最近一层的循环。

#### continue 语句
continue 语句用于结束本次循环，继续下一次。多个循环嵌套时，continue 也是应用于最近的一层循环。

#### else 语句
while、for 循环可以附带一个 else 语句（可选）。如果 for、while 语句没有被 break 语句结束，则会执行 else 子句，否则不执行。
语法格式如下：
while 条件表达式：
    循环体
else:
    语句块

或者：
for 变量 in 可迭代对象：
    循环体
else:
    语句块

#### 循环代码优化
编写循环时，遵守下面三个原则可以大大提高运行效率，避免不必要的低效计算：
1. 尽量减少循环内部不必要的计算
2. 嵌套循环中，尽量减少内层循环的计算，尽可能向外提。
3. 局部变量查询较快，尽量使用局部变量

其他优化手段
1. 连接多个字符串，使用 join()而不使用+
2. 列表进行元素插入和删除，尽量在列表尾部操作

#### 使用 zip()并行迭代
我们可以通过 zip()函数对多个序列进行并行迭代，zip()函数在最短序列“用完”时就会停止。

### 推导式创建序列
推导式是从一个或者多个迭代器快速创建序列的一种方法。它可以将循环和条件判断结合，从而避免冗长的代码。
推导式是典型的 Python 风格，会使用它代表你已经超过 Python 初学者的水平。 

#### 列表推导式
列表推导式生成列表对象，语法如下：
[表达式 for item in 可迭代对象 ]
或者：
{表达式 for item in 可迭代对象 if 条件判断}

#### 字典推导式
字典的推导式生成字典对象，格式如下：
{key_expression : value_expression for 表达式 in 可迭代对象}
类似于列表推导式，字典推导也可以增加 if 条件判断、多个 for 循环。

#### 集合推导式
集合推导式生成集合，和列表推导式的语法格式类似：
{表达式 for item in 可迭代对象 }
或者：
{表达式 for item in 可迭代对象 if 条件判断}

#### 生成器推导式（生成元组）
很多同学可能会问：“都有推导式，元组有没有？”，能不能用小括号呢？
>>> (x for x in range(1,100) if x%9==0)
<generator object <genexpr> at 0x0000000002BD3048>
我们发现提示的是“一个生成器对象”。显然，元组是没有推导式的。
一个生成器只能运行一次。第一次迭代可以得到数据，第二次迭代发现数据已经没有了

## 第 5 章 函数用法和底层分析
函数是可重用的程序代码块。
函数的作用，不仅可以实现代码的复用，更能实现代码的一致性。
一致性指的是，只要修改函数的代码，则所有调用该函数的地方都能得到体现。

函数简介
### 函数的基本概念
1. 一个程序由一个个任务组成；函数就是代表一个任务或者一个功能。
2. 函数是代码复用的通用机制。

### Python 函数的分类
Python 中函数分为如下几类：
1. 内置函数
我们前面使用的 str()、list()、len()等这些都是内置函数，我们可以拿来直接使用。
2. 标准库函数
我们可以通过 import 语句导入库，然后使用其中定义的函数
3. 第三方库函数
Python 社区也提供了很多高质量的库。下载安装这些库后，也是通过 import 语句导入，然后可以使用这些第三方库的函数
4. 用户自定义函数
用户自己定义的函数，显然也是开发中适应用户自身需求定义的函数。今天我们学习的就是如何自定义函数。

### 函数的定义和调用
核心要点
Python 中，定义函数的语法如下：
def 函数名 ([参数列表]) : 
    '''文档字符串''' 
    函数体/若干语句

要点：
1. 我们使用 def 来定义函数，然后就是一个空格和函数名称；
    (1) Python 执行 def 时，会创建一个函数对象，并绑定到函数名变量上。
2. 参数列表
    (1) 圆括号内是形式参数列表，有多个参数则使用逗号隔开
    (2) 形式参数不需要声明类型，也不需要指定函数返回值类型
    (3) 无参数，也必须保留空的圆括号
    (4) 实参列表必须与形参列表一一对应
3. return 返回值
    (1) 如果函数体中包含 return 语句，则结束函数执行并返回值；
    (2) 如果函数体中不包含 return 语句，则返回 None 值。
4. 调用函数之前，必须要先定义函数，即先调用 def 创建函数对象
    (1) 内置函数对象会自动创建
    (2) 标准库和第三方库函数，通过 import 导入模块时，会执行模块中的 def 语句

### 形参和实参
上面的 printMax 函数中，在定义时写的 printMax(a,b)。a 和 b 称为“形式参数”，简称“形参”。
也就是说，形式参数是在定义函数时使用的。 形式参数的命名只要符合“标识符”命名规则即可。
在调用函数时，传递的参数称为“实际参数”，简称“实参”。

### 文档字符串(函数的注释)
程序的可读性最重要，一般建议在函数体开始的部分附上函数定义说明，这就是“文档字符串”，也有人成为“函数的注释”。
我们通过三个单引号或者三个双引号来实现，中间可以加入多行文字进行说明。

### 返回值
return 返回值要点：
    1. 如果函数体中包含 return 语句，则结束函数执行并返回值；
    2. 如果函数体中不包含 return 语句，则返回 None 值。
    3. 要返回多个返回值，使用列表、元组、字典、集合将多个值“存起来”即可。

### 函数也是对象，内存底层分析
Python 中，“一切都是对象”。实际上，执行 def 定义函数后，系统就创建了相应的函数对象。

### 变量的作用域(全局变量和局部变量)
变量起作用的范围称为变量的作用域，不同作用域内同名变量之间互不影响。变量分为：全
局变量、局部变量。

#### 全局变量：
    1. 在函数和类定义之外声明的变量。作用域为定义的模块，从定义位置开始直到模块结束。
    2. 全局变量降低了函数的通用性和可读性。应尽量避免全局变量的使用。
    3. 全局变量一般做常量使用。
    4. 函数内要改变全局变量的值，使用 global 声明一下
#### 局部变量：
    1. 在函数体中（包含形式参数）声明的变量。
    2. 局部变量的引用比全局变量快，优先考虑使用。
    3. 如果局部变量和全局变量同名，则在函数内隐藏全局变量，只使用同名的局部变量

#### 局部变量和全局变量效率测试
局部变量的查询和访问速度比全局变量快，优先考虑使用，尤其是在循环的时候。
在特别强调效率的地方或者循环次数较多的地方，可以通过将全局变量转为局部变量提高运行速度。

### 参数的传递
函数的参数传递本质上就是：从实参到形参的赋值操作。 Python 中“一切皆对象”，
所有的赋值操作都是“引用的赋值”。所以，Python 中参数的传递都是“引用传递”，不是“值传递”。
具体操作时分为两类：
    1. 对“可变对象”进行“写操作”，直接作用于原对象本身。
    2. 对“不可变对象”进行“写操作”，会产生一个新的“对象空间”，并用新的值填充这块空间。（起到其他语言的“值传递”效果，但不是“值传递”）

可变对象有：
    字典、列表、集合、自定义的对象等
不可变对象有：
    数字、字符串、元组、function 等

#### 传递可变对象的引用
传递参数是可变对象（例如：列表、字典、自定义的其他可变对象等），实际传递的还是对
象的引用。在函数体中不创建新的对象拷贝，而是可以直接修改所传递的对象。

#### 传递不可变对象的引用
传递参数是不可变对象（例如：int、float、字符串、元组、布尔值），实际传递的还是对
象的引用。在”赋值操作”时，由于不可变对象无法修改，系统会新创建一个对象。

#### 浅拷贝和深拷贝
为了更深入的了解参数传递的底层原理，我们需要讲解一下“浅拷贝和深拷贝”。我们可以使用内置函数：copy(浅拷贝)、deepcopy(深拷贝)。
浅拷贝：不拷贝子对象的内容，只是拷贝子对象的引用。
深拷贝：会连子对象的内存也全部拷贝一份，对子对象的修改不会影响源对象

#### 传递不可变对象包含的子对象是可变的情况
传递不可变对象时。不可变对象里面包含的子对象是可变的。则方法内修改了这个可变对象，源对象也发生了变化

### 参数的几种类型
#### 位置参数
函数调用时，实参默认按位置顺序传递，需要个数和形参匹配。按位置传递的参数，称为：“位置参数”。

#### 默认值参数
我们可以为某些参数设置默认值，这样这些参数在传递时就是可选的。称为“默认值参数”。
默认值参数放到位置参数后面

#### 命名参数
我们也可以按照形参的名称传递参数，称为“命名参数”，也称“关键字参数”。

#### 可变参数
可变参数指的是“可变数量的参数”。分两种情况：
1. *param（一个星号），将多个参数收集到一个“元组”对象中。
2. **param（两个星号），将多个参数收集到一个“字典”对象中。

#### 强制命名参数
在带星号的“可变参数”后面增加新的参数，必须在调用的时候“强制命名参数”。

#### lambda 表达式和匿名函数
lambda 表达式可以用来声明匿名函数。lambda 函数是一种简单的、在同一行中定义函数的方法。
lambda 函数实际生成了一个函数对象。lambda 表达式只允许包含一个表达式，不能包含复杂语句，该表达式的计算结果就是函数的返回值。

lambda 表达式的基本语法如下：
    lambda arg1,arg2,arg3... : <表达式>
arg1/arg2/arg3 为函数的参数。<表达式>相当于函数体。运算结果是：表达式的运算结果。

#### eval()函数
功能：将字符串 str 当成有效的表达式来求值并返回计算结果。
语法： eval(source[, globals[, locals]]) -> value
参数：
    source：一个 Python 表达式或函数 compile()返回的代码对象
    globals：可选。必须是 dictionary
    locals：可选。任意映射对象

eval 函数会将字符串当做语句来执行，因此会被注入安全隐患。比如：字符串中含有删除文件的语句。那就麻烦大了。因此，使用时候，要慎重！！！

#### 递归函数
递归函数指的是：自己调用自己的函数，在函数体内部直接或间接的自己调用自己。递归类似于大家中学数学学习过的“数学归纳法”。 
每个递归函数必须包含两个部分：
1. 终止条件
    表示递归什么时候结束。一般用于返回值，不再调用自己。
2. 递归步骤
    把第 n 步的值和第 n-1 步相关联。
#### 课外知识：分形几何

递归函数由于会创建大量的函数对象、过量的消耗内存和运算能力。在处理大量数据时，谨慎使用。

#### 嵌套函数(内部函数)
嵌套函数：
    在函数内部定义的函数！
嵌套函数定义
def f1():
    print('f1 running...')
    def f2():
        print('f2 running...')
    f2()
f1()

一般在什么情况下使用嵌套函数？
1. 封装 - 数据隐藏
    外部无法访问“嵌套函数”。
2. 贯彻 DRY(Don’t Repeat Yourself) 原则
    嵌套函数，可以让我们在函数内部避免重复代码。
3. 闭包
    后面会详细讲解。

#### nonlocal 关键字
nonlocal 用来声明外层的局部变量。
global 用来声明全局变量

#### LEGB 规则
Python 在查找“名称”时，是按照 LEGB 规则查找的：
Local-->Enclosed-->Global-->Built in
    Local 指的就是函数或者类的方法内部
    Enclosed 指的是嵌套函数（一个函数包裹另一个函数，闭包）
    Global 指的是模块中的全局变量
    Built in 指的是 Python 为自己保留的特殊名称。
如果某个 name 映射在局部(local)命名空间中没有找到，
接下来就会在闭包作用域(enclosed)进行搜索，
如果闭包作用域也没有找到，Python 就会到全局(global)命名空间中进行查找，
最后会在内建(built-in)命名空间搜索 
（如果一个名称在所有命名空间中都没有找到，就会产生一个 NameError）。

## 第 6 章(1) 面向对象初步
面向对象（Object oriented Programming，OOP）编程的思想主要是针对大型软件设计而来的。面向对象编程使程序的扩展性更强、可读性更好，使的编程可以像搭积木一样简单。
面向对象编程将数据和操作数据相关的方法封装到对象中，组织代码和数据的方式更加接近人的思维，从而大大提高了编程的效率。
Python 完全采用了面向对象的思想，是真正面向对象的编程语言，完全支持面向对象的基本功能，例如：继承、多态、封装等。
Python 中，一切皆对象。我们在前面学习的数据类型、函数等，都是对象。
注：Python 支持面向过程、面向对象、函数式编程等多种编程范式。

### 面向对象和面向过程区别
#### ·面向过程(Procedure Oriented)思维
面向过程编程更加关注的是“程序的逻辑流程”，是一种“执行者”思维，适合编写小规模的程序。
面向过程思想思考问题时，我们首先思考“怎么按步骤实现？”并将步骤对应成方法，一步一步，最终完成。 
这个适合简单任务，不需要过多协作的情况下。比如，如何开车？
我们很容易就列出实现步骤：

面向过程适合简单、不需要协作的事务。 但是当我们思考比较复杂的问题，比如“如何造车？”，就会发现列出 1234 这样的步骤，是不可能的。
那是因为，造车太复杂，需要很多协作才能完成。此时面向对象思想就应运而生了。

#### ·面向对象(Object Oriented)思维
面向对象更加关注的是“软件中对象之间的关系”，是一种“设计者”思维，适合编写大规模的程序。
面向对象(Object)思想更契合人的思维模式。我们首先思考的是“怎么设计这个事物？”
比如思考造车，我们就会先思考“车怎么设计？”，而不是“怎么按步骤造车的问题”。这就是思维方式的转变。

面向对象方式思考造车，发现车由如下对象组成：
1. 轮胎
2. 发动机
3. 车壳
4. 座椅
5. 挡风玻璃
为了便于协作，我们找轮胎厂完成制造轮胎的步骤，发动机厂完成制造发动机的步骤；这样，发现大家可以同时进行车的制造，最终进行组装，大大提高了效率。
但是，具体到轮胎厂的一个流水线操作，仍然是有步骤的，还是离不开面向过程思想！
因此，面向对象可以帮助我们从宏观上把握、从整体上分析整个系统。 但是，具体到实现部分的微观操作（就是一个个方法），仍然需要面向过程的思路去处理。
我们千万不要把面向过程和面向对象对立起来。他们是相辅相成的。面向对象离不开面向过程！

#### 面向对象思考方式
遇到复杂问题，先从问题中找名词（面向过程更多的是找动词），然后确立这些名词哪些可以作为类，再根据问题需求确定的类的属性和方法，确定类之间的关系。

#### 面向对象和面向过程的总结
 都是解决问题的思维方式，都是代码组织的方式。
 解决简单问题可以使用面向过程
 解决复杂问题：宏观上使用面向对象把握，微观处理上仍然是面向过程。

一个好的“设计者”肯定也是“好的执行者”，不然无法落地，白忙一场。
一个好的“执行者”不一定是“好的设计者”，眼界层次不够，越忙越乱。

#### 对象的进化
随着编程面临的问题越来越复杂，编程语言本身也在进化，从主要处理简单数据开始，随着数据变多进化“数组”； 数据类型变复杂，进化出了“结构体”； 处理数据的方式和逻辑变复杂，进化出了“对象”。

1. 简单数据
    像 30,40，50.4 等这些数字，可以看做是简单数据。最初的计算机编程，都是像这样的数字。
2. 数组
    将同类型的数据放到一起。比如：整数数组[20,30,40]，浮点数数组[10.2, 11.3, 12.4]，字符串数组：[“aa”,”bb”,”cc”]
3. 结构体
    将不同类型的数据放到一起，是 C 语言中的数据结构。比如：
    struct resume{
        int age;
        char name[10];
        double salary;
    };
4. 对象
    将不同类型的数据、方法（即函数）放到一起，就是对象。
    我们前面学习的数字也是对象。比如：整数 9，就是一个包含了加法、乘法等方法的对象。

#### 类的定义
我们通过类定义数据类型的属性（数据）和方法（行为）,也就是说，“类将行为和状态打包在一起”
对象是类的具体实体，一般称为“类的实例”。

从一个类创建对象时，每个对象会共享这个类的行为（类中定义的方法），但会有自己的属性值（不共享状态）。更具体一点：“方法代码是共享的，属性数据不共享”。

Python 中，“一切皆对象”。类也称为“类对象”，类的实例也称为“实例对象”。
定义类的语法格式如下：
class 类名：
    类体

要点如下：
1. 类名必须符合“标识符”的规则；一般规定，首字母大写，多个单词使用“驼峰原则”。
2. 类体中我们可以定义属性和方法。
3. 属性用来描述数据，方法(即函数)用来描述这些数据相关的操作。

#### __init__构造方法和__new__方法
类是抽象的，也称之为“对象的模板”。我们需要通过类这个模板，创建类的实例对象，然后才能使用类定义的功能

我们前面说过一个 Python 对象包含三个部分：id（identity 识别码）、type（对象类型）、value（对象的值）。
现在，我们可以更进一步的说，一个 Python 对象包含如下部分：
    1. id（identity 识别码）
    2. type（对象类型）
    3. value（对象的值）
        (1) 属性（attribute）
        (2) 方法（method）

创建对象，我们需要定义构造函数__init__()方法。构造方法用于执行“实例对象的初始化工作”，即对象创建后，初始化当前对象的相关属性，无返回值。

__init__()的要点如下：
1. 名称固定，必须为：__init__()
2. 第一个参数固定，必须为：self。 self 指的就是刚刚创建好的实例对象。
3. 构造函数通常用来初始化实例对象的实例属性，如下代码就是初始化实例属性：name和 score。
4. 通过“类名(参数列表)”来调用构造函数。调用后，将创建好的对象返回给相应的变量。比如：s1 = Student('张三', 80)
5. __init__()方法：初始化创建好的对象，初始化指的是：“给实例属性赋值”
6. __new__()方法: 用于创建对象，但我们一般无需重定义该方法。
7. 如果我们不定义__init__方法，系统会提供一个默认的__init__方法。如果我们定义了带参的__init__方法，系统不创建默认的__init__方法。

注：
1. Python 中的 self 相当于 C++中的 self 指针，JAVA 和 C#中的 this 关键字。Python 中，self 必须为构造函数的第一个参数，名字可以任意修改。但一般遵守惯例，都叫做 self。

### 实例属性和实例方法
#### 实例属性
实例属性是从属于实例对象的属性，也称为“实例变量”。他的使用有如下几个要点：
    1. 实例属性一般在__init__()方法中通过如下代码定义：
        self.实例属性名 = 初始值
    2. 在本类的其他实例方法中，也是通过 self 进行访问：
        self.实例属性名
    3. 创建实例对象后，通过实例对象访问：
        obj01 = 类名() #创建对象，调用__init__()初始化属性
        obj01.实例属性名 = 值 #可以给已有属性赋值，也可以新加属性

#### 实例方法
实例方法是从属于实例对象的方法。实例方法的定义格式如下：
def 方法名(self [, 形参列表])：
    函数体
方法的调用格式如下：
    对象.方法名([实参列表])

要点：
1. 定义实例方法时，第一个参数必须为 self。和前面一样，self 指当前的实例对象。
2. 调用实例方法时，不需要也不能给 self 传参。self 由解释器自动传参。

#### · 函数和方法的区别
1. 都是用来完成一个功能的语句块，本质一样。
2. 方法调用时，通过对象来调用。方法从属于特定实例对象，普通函数没有这个特点。
3. 直观上看，方法定义时需要传递 self，函数不需要。

#### 实例对象的方法调用本质：
a.say_score() 
解释器翻译：
Student.say_score(a)

#### 其他操作：
1. dir(obj)可以获得对象的所有属性、方法
2. obj.__dict__ 对象的属性字典
3. pass 空语句
4. isinstance（对象,类型） 判断“对象”是不是“指定类型”

### 类对象、类属性、类方法、静态方法
#### 类对象
我们在前面讲的类定义格式中，“class 类名：”。实际上，当解释器执行 class 语句时，就会创建一个类对象。

我们可以看到实际上生成了一个变量名就是类名“Student”的对象。我们通过赋值给新变量 Stu2，也能实现相关的调用。说明，确实创建了“类对象”。

#### 类属性
类属性是从属于“类对象”的属性，也称为“类变量”。由于，类属性从属于类对象，可以被所有实例对象共享。
类属性的定义方式：
class 类名：
    类变量名= 初始值

在类中或者类的外面，我们可以通过：“类名.类变量名”来读

#### 类方法
类方法是从属于“类对象”的方法。类方法通过装饰器@classmethod 来定义，格式如下：
    @classmethod
    def 类方法名(cls [，形参列表]) ：
        函数体

要点如下：
1. @classmethod 必须位于方法上面一行
2. 第一个 cls 必须有；cls 指的就是“类对象”本身；
3. 调用类方法格式：“类名.类方法名(参数列表)”。 参数列表中，不需要也不能给 cls 传值。
4. 类方法中访问实例属性和实例方法会导致错误
5. 子类继承父类方法时，传入 cls 是子类对象，而非父类对象

#### 静态方法
Python 中允许定义与“类对象”无关的方法，称为“静态方法”。
“静态方法”和在模块中定义普通函数没有区别，只不过“静态方法”放到了“类的名字空间里面”，需要通过“类调用”。
静态方法通过装饰器@staticmethod 来定义，格式如下：
@staticmethod
def 静态方法名([形参列表]) ：
    函数体

要点如下：
1. @staticmethod 必须位于方法上面一行
2. 调用静态方法格式：“类名.静态方法名(参数列表)”。
3. 静态方法中访问实例属性和实例方法会导致错误

#### 内存分析实例对象和类对象创建过程（重要）

#### __del__方法(析构函数)和垃圾回收机制
__del__方法称为“析构方法”，用于实现对象被销毁时所需的操作。比如：释放对象占用的资源，例如：打开的文件资源、网络连接等。
Python 实现自动的垃圾回收，当对象没有被引用时（引用计数为 0），由垃圾回收器调用__del__方法。
我们也可以通过 del 语句删除对象，从而保证调用__del__方法。
系统会自动提供__del__方法，一般不需要自定义析构方法。

#### __call__方法和可调用对象
定义了__call__方法的对象，称为“可调用对象”，即该对象可以像函数一样被调用。

#### 方法没有重载
在其他语言中，可以定义多个重名的方法，只要保证方法签名唯一即可。方法签名包含 3个部分：方法名、参数数量、参数类型。

Python 中，方法的的参数没有声明类型（调用时确定参数的类型），参数的数量也可以由可变参数控制。
因此，Python 中是没有方法的重载的。定义一个方法即可有多种调用方式，相当于实现了其他语言中的方法的重载。

如果我们在类体中定义了多个重名的方法，只有最后一个方法有效。
建议：不要使用重名的方法！Python 中方法没有重载。

#### 方法的动态性
Python 是动态语言，我们可以动态的为类添加新的方法，或者动态的修改类的已有的方法。

#### 私有属性和私有方法(实现封装)
Python 对于类的成员没有严格的访问控制限制，这与其他面向对象语言有区别。关于私有属性和私有方法，有如下要点：
    1. 通常我们约定，两个下划线开头的属性是私有的(private)。其他为公共的(public)。
    2. 类内部可以访问私有属性(方法)
    3. 类外部不能直接访问私有属性(方法)
    4. 类外部可以通过“_类名__私有属性(方法)名”访问私有属性(方法)

【注】方法本质上也是属性！只不过是可以通过()执行而已。所以，此处讲的私有属性和公有属性，也同时讲解了私有方法和公有方法的用法。如下测试中，同时也包含了私有方法和公有方法的例子。

#### @property 装饰器
@property 可以将一个方法的调用方式变成“属性调用”。
@property 主要用于帮助我们处理属性的读操作、写操作。对于某一个属性，我们可以直接通过：

如上的操作读操作、写操作。但是，这种做法不安全。比如，我需要限制薪水必须为 1-10000
的数字。这时候，我们就需要通过 getter、setter 方法来处理。

#### 属性和方法命名总结
· _xxx：保护成员，不能用“from module import * ”导入，只有类对象和子类对象能访问这些成员。
· __xxx__：系统定义的特殊成员
· __xxx： 类中的私有成员，只有类对象自己能访问，子类对象也不能访问。（但，在类外部可以通过“对象名. _类名__xxx”这种特殊方式访问。Python 不存在严格意义的私有成员）

注：再次强调，方法和属性都遵循上面的规则。

#### 类编码风格
1. 类名首字母大写，多个单词之间采用驼峰原则。
2. 实例名、模块名采用小写，多个单词之间采用下划线隔开。
3. 每个类，应紧跟“文档字符串”，说明这个类的作用。
4. 可以用空行组织代码，但不能滥用。在类中，使用一个空行隔开方法；模块中，使用两个空行隔开多个类。

### 实操作业

## 第 6 章(2) 面向对象进阶

### 面向对象三大特征介绍
Python 是面向对象的语言，也支持面向对象编程的三大特性：继承、封装（隐藏）、多态。

 ·封装（隐藏）
    隐藏对象的属性和实现细节，只对外提供必要的方法。相当于将“细节封装起来”，只对外暴露“相关调用方法”。
    通过前面学习的“私有属性、私有方法”的方式，实现“封装”。Python 追求简洁的语法，没有严格的语法级别的“访问控制符”，更多的是依靠程序员自觉实现。

 ·继承
    继承可以让子类具有父类的特性，提高了代码的重用性。
    从设计上是一种增量进化，原有父类设计不变的情况下，可以增加新的功能，或者改进已有的算法。

 ·多态
    多态是指同一个方法调用由于对象不同会产生不同的行为。
    生活中这样的例子比比皆是：同样是休息方法，人不同休息方法不同。张三休息是睡觉，李四休息是玩游戏，程序员休息是“敲几行代码”。

### 继承
继承是面向对象程序设计的重要特征，也是实现“代码复用”的重要手段。
如果一个新类继承自一个设计好的类，就直接具备了已有类的特征，就大大降低了工作难度。
已有的类，我们称为“父类或者基类”，新的类，我们称为“子类或者派生类”。

语法格式
Python 支持多重继承，一个子类可以继承多个父类。继承的语法格式如下：
class 子类类名(父类 1[，父类 2，...])：
    类体

如果在类定义中没有指定父类，则默认父类是 object 类。也就是说，object 是所有类的父类，里面定义了一些所有类共有的默认实现，比如：__new__()。

定义子类时，必须在其构造函数中调用父类的构造函数。调用格式如下：
父类名.__init__(self, 参数列表)

#### 类成员的继承和重写
1. 成员继承：子类继承了父类除构造方法之外的所有成员。
2. 方法重写：子类可以重新定义父类中的方法，这样就会覆盖父类的方法，也称为“重写”

#### 查看类的继承层次结构
通过类的方法 mro()或者类的属性__mro__可以输出这个类的继承层次结构。

### object 根类
object 类是所有类的父类，因此所有的类都有 object 类的属性和方法。我们显然有必要深入研究一下 object 类的结构。对于我们继续深入学习 Python 很有好处。

dir()查看对象属性
为了深入学习对象，我们先学习内置函数 dir()，他可以让我们方便的看到指定对象所有的属性

从上面我们可以发现这样几个要点：
1. Person 对象增加了六个属性：
__dict__ __module__ __weakref__ age name say_age
2. object 的所有属性，Person 类作为 object 的子类，显然包含了所有的属性。
3. 我们打印 age、name、say_age，发现 say_age 虽然是方法，实际上也是属性。只不过，这个属性的类型是“method”而已。
age <class 'int'>
name <class 'str'>
say_age <class 'method'>
【注】关于 object 这些属性的详细学习，会在后面学习中逐个涉及。在此，无法一一展开。

#### 重写__str__()方法
object 有一个__str__()方法，用于返回一个对于“对象的描述”，对应于内置函数 str()
经常用于 print()方法，帮助我们查看对象的信息。__str__()可以重写。

#### 多重继承
Python 支持多重继承，一个子类可以有多个“直接父类”。这样，就具备了“多个父类”的特点。但是由于，这样会被“类的整体层次”搞的异常复杂，尽量避免使用。

#### MRO()
Python 支持多继承，如果父类中有相同名字的方法，在子类没有指定父类名时，解释器将“从左向右”按顺序搜索。 
MRO（Method Resolution Order）：方法解析顺序。 我们可以通过 mro()方法获得“类的层次结构”，方法解析顺序也是按照这个“类的层次结构”寻找的。

#### super()获得父类定义
在子类中，如果想要获得父类的方法时，我们可以通过 super()来做。
super()代表父类的定义，不是父类对象。

### 多态
多态（polymorphism）是指同一个方法调用由于对象不同可能会产生不同的行为。

关于多态要注意以下 2 点：
1. 多态是方法的多态，属性没有多态。
2. 多态的存在有 2 个必要条件：继承、方法重写。

#### 特殊方法和运算符重载
Python 的运算符实际上是通过调用对象的特殊方法实现的。

常见的特殊方法统计如下：
方法                说明        例子
__init__            构造方法    对象创建：p = Person() 
__del__             析构方法    对象回收
__repr__,__str__    打印，转换  print(a) 
__call__            函数调用    a() 
__getattr__         点号运算    a.xxx
__setattr__         属性赋值    a.xxx = value
__getitem__         索引运算    a[key] 
__setitem__         索引赋值    a[key]=value
__len__             长度        len(a)

每个运算符实际上都对应了相应的方法，统计如下：
运算符      特殊方法                说明
运算符+     __add__                 加法
运算符-     __sub__                 减法
<,<=,==    __lt__,__le__，__eq__    比较运算符
>,>=,!=    __gt__,__ge__,__ne__
|,^,&      __or__,__xor__,__and__   或、异或、与
<<,>>      __lshift__,__rshift__    左移、右移
*,/,%,//   __mul__,__truediv__,__mod__,__floordiv__     乘、浮点除、模运算（取余）、整数除
**         __pow__                  指数运算

我们可以重写上面的特殊方法，即实现了“运算符的重载”。

#### 特殊属性
Python 对象中包含了很多双下划线开始和结束的属性，这些是特殊属性，有特殊用法。
这里我们列出常见的特殊属性：
特殊方法                含义
obj.__dict__            对象的属性字典
obj.__class__           对象所属的类
class.__bases__         类的基类元组（多继承）
class.__base__          类的基类
class.__mro__           类层次结构
class.__subclasses__()  子类列表

#### 对象的浅拷贝和深拷贝
·变量的赋值操作
    只是形成两个变量，实际还是指向同一个对象。
·浅拷贝
    Python 拷贝一般都是浅拷贝。拷贝时，对象包含的子对象内容不拷贝。因此，源对象和拷贝对象会引用同一个子对象。
·深拷贝
    使用 copy 模块的 deepcopy 函数，递归拷贝对象中包含的子对象。源对象和拷贝对象所有的子对象也不同。

#### 组合
“is-a”关系，我们可以使用“继承”。从而实现子类拥有的父类的方法和属性。“is-a”关系指的是类似这样的关系：狗是动物，dog is animal。狗类就应该继承动物类。

“has-a”关系，我们可以使用“组合”，也能实现一个类拥有另一个类的方法和属性。”has-a”关系指的是这样的关系：手机拥有 CPU。 MobilePhone has a CPU。

### 设计模式_工厂模式实现
设计模式是面向对象语言特有的内容，是我们在面临某一类问题时候固定的做法，设计模式有很多种，比较流行的是：GOF（Goup Of Four）23 种设计模式。

对于初学者，我们学习两个最常用的模式：工厂模式和单例模式。
工厂模式实现了创建者和调用者的分离，使用专门的工厂类将选择实现类、创建对象进行统一的管理和控制。

### 设计模式_单例模式实现
单例模式（Singleton Pattern）的核心作用是确保一个类只有一个实例，并且提供一个访问该实例的全局访问点。

单例模式只生成一个实例对象，减少了对系统资源的开销。当一个对象的产生需要比较多的资源，如读取配置文件、产生其他依赖对象时，可以产生一个“单例对象”，然后永久驻留内存中，从而极大的降低开销。

单例模式有多种实现的方式，我们这里推荐重写__new__()的方法。

## 第九章 导引问题
在实际工作中，我们遇到的情况不可能是非常完美的。
软件程序在运行过程中，非常可能遇到刚刚提到的这些问题，我们称之为异常，英文是：Exception，意思是例外。遇到这些例外情况，或者叫异常，

这种方式，有两个坏处：
    1. 逻辑代码和错误处理代码放一起!
    2. 程序员本身需要考虑的例外情况较复杂，对程序员本身要求较高!
那么，我们如何解决应对异常情况呢? python 的异常机制给我们提供了方便的处理方式。

### 异常机制本质
异常指程序运行过程中出现的非正常现象，例如用户输入错误、除数为零、需要处理的文件不存在、数组下标越界等。
所谓异常处理，就是指程序在出现问题时依然可以正确的执行剩余的程序，而不会因为异常而终止程序执行。

python 中，引进了很多用来描述和处理异常的类，称为异常类。异常类定义中包含了该类异常的信息和对异常进行处理的方法。
下面较为完整的展示了python 中内建异常类的继承层次：

python 中一切都是对象，异常也采用对象的方式来处理。处理过程：
    1. 抛出异常：在执行一个方法时，如果发生异常，则这个方法生成代表该异常的一个对象，停止当前执行路径，并把异常对象提交给解释器。
    2. 捕获异常：解释器得到该异常后，寻找相应的代码来处理该异常。

### 解决异常问题的态度
学习完异常相关知识点，只是开始对异常有些认识，不意味着你会调试任何异常；调试异常，需要大量的经验作为基础。因此，大家不要在此停留，继续往后学习。碰到每个异常，都要花心思去解决而不要动不动张口问人。通过自己的努力无法解决，再去找老师同学帮助解决。

解决每一个遇到的异常，建议大家遵循如下三点：
    1. 不慌张，细看信息，定位错误。看清楚报的错误信息，并定位发生错误的地方。
    2. 百度并查看十个相关帖子。将异常类信息进行百度，至少查看十个以上的相关帖子。
    3. 以上两步仍然无法解决，找老师和同学协助解决。
正常情况，自己遵循如上步骤解决 30 个以上的错误，就能积累初步的调试经验，以后遇到的大部分错误都能独立完成

### 异常解决的关键：定位
当发生异常时，解释器会报相关的错误信息，并会在控制台打印出相关错误信息。
我们只需按照从上到下的顺序即可追溯（Trackback）错误发生的过程，最终定位引起错误的那一行代码。

### try...一个 except 结构
try...except 是最常见的异常处理结构。结构如下：
try:
    被监控的可能引发异常的语句块
except BaseException [as e]:
    异常处理语句块

try 块包含着可能引发异常的代码，except 块则用来捕捉和处理发生的异常。
执行的时候，如果 try 块中没有引发异常，则跳过 ecept 块继续执行后续代码；
执行的时候，如果 try块中发生了异常，则跳过 try 块中的后续代码，跳到相应的 except 块中处理异常；
异常处理完后，继续执行后续代码。

#### try...多个 except 结构
上面的结构可以捕获所有的异常，工作中也很常见。
但是，从经典理论考虑，一般建议尽量捕获可能出现的多个异常（按照先子类后父类的顺序），并且针对性的写出异常处理代码。
为了避免遗漏可能出现的异常，可以在最后增加 BaseException。结构如下：

try:
    被监控的、可能引发异常的语句块
except Exception1:
    处理 Exception1 的语句块
except Exception2:
    处理 Exception2 的语句块
... except BaseException：
    处理可能遗漏的异常的语句块

#### try...except...else 结构
try...except...else 结构增加了“else 块”。
如果 try 块中没有抛出异常，则执行 else 块。
如果try 块中抛出异常，则执行 except 块，不执行 else 块。

#### try...except...finally 结构
try...except...finally 结构中，finally 块无论是否发生异常都会被执行；通常用来释放 try 块中申请的资源。

#### return 语句和异常处理问题
由于 return 有两种作用：结束方法运行、返回值。我们一般不把 return 放到异常处理结构中，而是放到方法最后。

#### 常见异常的解决
Python 中的异常都派生自 BaseException 类，本节我们测试和列出常见的一些异常，方便初学者掌握

##### 1. SyntaxError：语法错误
int a = 3
    
int a =3
^
SyntaxError: invalid syntax

##### 2. NameError：尝试访问一个没有申明的变量
print(a)

print(a)
NameError: name 'a' is not defined

##### 3. ZeroDivisionError：除数为 0 错误（零除错误）
a = 3/0

a = 3/0
ZeroDivisionError: division by zero

##### 5. TypeError：类型错误
123+"abc"

123+"abc" 
TypeError: unsupported operand type(s) for +: 'int' and 'str

##### 6. AttributeError：访问对象的不存在的属性
a=100
a.sayhi()

a.sayhi()
AttributeError: 'int' object has no attribute 'sayhi'

##### 7. IndexError：索引越界异常
a = [4,5,6]
a[10]

a[10]
IndexError: list index out of range

##### 8. KeyError：字典的关键字不存在
a = {'name':"gaoqi",'age':18}
a['salary']

a['salary']
KeyError: 'salary

#### 常见异常汇总
建议大家通读，把异常相关的单词背下来熟悉一下。这样可以克服“畏难情绪”。

异常名称 说明
ArithmeticError         所有数值计算错误的基类
AssertionError          断言语句失败
AttributeError          对象没有这个属性
BaseException           所有异常的基类
DeprecationWarning      关于被弃用的特征的警告
EnvironmentError        操作系统错误的基类
EOFError                没有内建输入,到达 EOF 标记
Exception               常规错误的基类
FloatingPointError      浮点计算错误
FutureWarning           关于构造将来语义会有改变的警告
GeneratorExit           生成器(generator)发生异常来通知退出
ImportError             导入模块/对象失败
IndentationError        缩进错误
IndexError              序列中没有此索引(index)
IOError                 输入/输出操作失败
KeyboardInterrupt       用户中断执行(通常是输入^C)
KeyError                映射中没有这个键
LookupError             无效数据查询的基类
MemoryError             内存溢出错误(对于 Python 解释器不是致命的)
NameError               未声明/初始化对象 (没有属性)
NotImplementedError     尚未实现的方法
OSError                 操作系统错误
OverflowError           数值运算超出最大限制
OverflowWarning         旧的关于自动提升为长整型(long)的警告
PendingDeprecationWarning 关于特性将会被废弃的警告
ReferenceError          弱引用(Weak reference)试图访问已经垃圾回收了的对象
RuntimeError            一般的运行时错误
RuntimeWarning          可疑的运行时行为(runtime behavior)的警告
StandardError           所有的内建标准异常的基类
StopIteration           迭代器没有更多的值
SyntaxError             Python 语法错误
SyntaxWarning           可疑的语法的警告
SystemError             一般的解释器系统错误
SystemExit              解释器请求退出
TabError                Tab 和空格混用
TypeError               对类型无效的操作
UnboundLocalError       访问未初始化的本地变量
UnicodeDecodeError      Unicode 解码时的错误
UnicodeEncodeError      Unicode 编码时错误
UnicodeError            Unicode 相关的错误
UnicodeTranslateError   Unicode 转换时错误
UserWarning             用户代码生成的警告
ValueError              传入无效的参数
Warning                 警告的基类
WindowsError            系统调用失败
ZeroDivisionError       除(或取模)零 (所有数据类型)

#### with 上下文管理
finally 块由于是否发生异常都会执行，通常我们放释放资源的代码。其实，我们可以通过 with 上下文管理，更方便的实现释放资源的操作。

with 上下文管理的语法结构如下：
with context_expr [ as var]：
    语句块

with 上下文管理可以自动管理资源，在 with 代码块执行完毕后自动还原进入该代码之前的现场或上下文。
不论何种原因跳出 with 块，不论是否有异常，总能保证资源正常释放。极大的简化了工作，在文件操作、网络通信相关的场合非常常用。

#### trackback 模块
【示例】使用 Traceback 模块打印异常信息
#coding=utf-8
import traceback
try:
    print("step1")
    num = 1/0
except:
    traceback.print_exc()

#### 自定义异常类
自定义异常类一般都是运行时异常，通常继承 Exception 或其子类即可。命名一般以 Error、Exception 为后缀。
自定义异常由 raise 语句主动抛出。



## 第七章 模块(module)
### 1. 模块化(module)程序设计理念
#### 1.1 模块和包概念的进化史
大家可以清晰的看到这发展的流程，核心的哲学思想就是“量变引起质变”、“物以类聚”。同样的思路，在企业管理、人的管理中思路完全一致。大家可以举一反三。
    1. Python 程序由模块组成。一个模块对应 python 源文件，一般后缀名是：.py。
    2. 模块由语句组成。运行 Python 程序时，按照模块中语句的顺序依次执行。
    3. 语句是 Python 程序的构造单元，用于创建对象、变量赋值、调用函数、控制语句等。

#### 1.2 标准库模块(standard library)
与函数类似，模块也分为标准库模块和用户自定义模块。
Python 标准库提供了操作系统功能、网络通信、文本处理、文件处理、数学运算等基本的功能。比如：random(随机数)、math(数学运算)、time(时间处理)、file(文件处理)、os(和操作系统交互)、sys(和解释器交互)等。
另外，Python 还提供了海量的第三方模块，使用方式和标准库类似。功能覆盖了我们能想象到的所有领域，比如：科学计算、WEB 开发、大数据、人工智能、图形系统等。

#### 1.3 为什么需要模块化编程
模块化编程有如下几个重要优势：
    1. 便于将一个任务分解成多个模块，实现团队协同开发，完成大规模程序
    2. 实现代码复用。一个模块实现后，可以被反复调用。
    3. 可维护性增强。

#### 1.4 模块化编程的流程
模块化编程的一般流程：
    1. 设计 API，进行功能描述。
    2. 编码实现 API 中描述的功能。
    3. 在模块中编写测试代码，并消除全局代码。
    4. 使用私有函数实现不被外部客户端调用的模块函数。

#### 1.5 模块的 API 和功能描述要点
API(Application Programming Interface 应用程序编程接口)是用于描述模块中提供的函数和类的功能描述和使用方式描述。
模块化编程中，首先设计的就是模块的 API（即要实现的功能描述），然后开始编码实现 API 中描述的功能。最后，在其他模块中导入本模块进行调用。
我们可以通过help(模块名)查看模块的API。一般使用时先导入模块 然后通过help函数查看

#### 1.6 模块的创建和测试代码
每个模块都有一个名称，通过特殊变量__name__可以获取模块的名称。
在正常情况下，模块名字对应源文件名。 
仅有一个例外，就是当一个模块被作为程序入口时（主程序、交互式提示符下），它的__name__的值为“__main__”。
我们可以根据这个特点，将模块源代码文件中的测试代码进行独立的处理。

#### 1.7 模块文档字符串和 API 设计
我们可以在模块的第一行增加一个文档字符串，用于描述模块的相关功能。然后，通过__doc__可以获得文档字符串的内容

### 2. 模块的导入
模块化设计的好处之一就是“代码复用性高”。写好的模块可以被反复调用，重复使用。模块的导入就是“在本模块中使用其他模块”。
#### 2.1 import 语句导入
import 语句的基本语法格式如下：
    import 模块名 #导入一个模块
    import 模块 1，模块 2… #导入多个模块
    import 模块名 as 模块别名 #导入模块并使用新名字

import 加载的模块分为四个通用类别：
    a.使用 python 编写的代码（.py 文件）；
    b.已被编译为共享库或 DLL 的 C 或 C++扩展；
    c.包好一组模块的包
    d.使用 C 编写并链接到 python 解释器的内置模块；

我们一般通过 import 语句实现模块的导入和使用，import 本质上是使用了内置函数__import__()。
当我们通过 import 导入一个模块时，python 解释器进行执行，最终会生成一个对象，这个对象就代表了被加载的模块。

#### 2.2 from…import 导入
Python 中可以使用 from…import 导入模块中的成员。基本语法格式如下：
    from 模块名 import 成员 1，成员 2，…

如果希望导入一个模块中的所有成员，则可以采用如下方式：
    from 模块名 import *

【注】尽量避免“from 模块名 import *”这种写法。* 它表示导入模块中所有的不是以下划线(_)开头的名字都导入到当前位置。 
但你不知道你导入什么名字，很有可能会覆盖掉你之前已经定义的名字。而且可读性极其的差。一般生产环境中尽量避免使用，学习时没有关系。

#### 2.3 import 语句和 from...import 语句的区别
import 导入的是模块。from...import 导入的是模块中的一个函数/一个类。

如果进行类比的话，import 导入的是“文件”，我们要使用该“文件”下的内容，必须前面加“文件名称”。
from...import 导入的是文件下的“内容”，我们直接使用这些“内容”即可，前面再也不需要加“文件名称”了。

【注】
1. from package import item 这种语法中，item 可以是包、模块，也可以是函数、类、变量。
2. import item1.item2 这种语法中，item 必须是包或模块，不能是其他。

#### 2.4 __import__()动态导入
import 语句本质上就是调用内置函数__import__()，我们可以通过它实现动态导入。
给__import__()动态传递不同的的参数值，就能导入不同的模块。

注意：一般不建议我们自行使用__import__()导入，其行为在 python2 和 python3 中有差异，会导致意外错误。如果需要动态导入可以使用 importlib 模块。

#### 2.5 模块的加载问题
当导入一个模块时， 模块中的代码都会被执行。不过，如果再次导入这个模块，则不会再次执行。

一个模块无论导入多少次，这个模块在整个解释器进程内有且仅有一个实例对象。

重新加载
    有时候我们确实需要重新加载一个模块，这时候可以使用：importlib.reload()方法


### 3. 包 package 的使用
#### 3.1 包(package)的概念和结构
当一个项目中有很多个模块时，需要再进行组织。我们将功能类似的模块放到一起，形成了“包”。
本质上，“包”就是一个必须有__init__.py 的文件夹。典型结构如下：

包下面可以包含“模块(module)”，也可以再包含“子包(subpackage)”。就像文件夹下面可以有文件，也可以有子文件夹一样。

上图中，a 是上层的包，下面有一个子包：aa。可以看到每个包里面都有__init__.py 文件。

#### 3.2 pycharm 中创建包

#### 3.3 导入包操作和本质
上一节中的包结构，我们需要导入 module_AA.py。方式如下：
    1. import a.aa.module_AA
        在使用时，必须加完整名称来引用，比如：a.aa.module_AA.fun_AA()
    2. from a.aa import module_AA
        在使用时，直接可以使用模块名。 比如：module_AA.fun_AA()
    3. from a.aa.module_AA import fun_AA 直接导入函数
        在使用时，直接可以使用函数名。 比如：fun_AA()

【注】
1. from package import item 这种语法中，item 可以是包、模块，也可以是函数、类、变量。
2. import item1.item2 这种语法中，item 必须是包或模块，不能是其他。

导入包的本质其实是“导入了包的__init__.py”文件。也就是说，”import pack1”意味着执行了包 pack1 下面的__init__.py 文件。 
这样，可以在__init__.py 中批量导入我们需要的模块，而不再需要一个个导入。

__init__.py 的三个核心作用：
1. 作为包的标识，不能删除。
2. 用来实现模糊导入
3. 导入包实质是执行__init__.py 文件，可以在__init__.py 文件中做这个包的初始化、以及需要统一执行代码、批量导入。

【注】如上测试我们可以看出 python 的设计者非常巧妙的通过__init__.py 文件将包转成了模块的操作。因此，可以说“包的本质还是模块”。

#### 3.4 用*导入包
import * 这样的语句理论上是希望文件系统找出包中所有的子模块，然后导入它们。这可能会花长时间等。Python 解决方案是提供一个明确的包索引。

这个索引由 __init__.py 定义 __all__ 变量，该变量为一列表，
如上例 a 包下的__init__.py 中，可定义 __all__ = ["module_A","module_A2"]

这意味着， from sound.effects import * 会从对应的包中导入以上两个子模块；

【注】尽管提供 import * 的方法，仍不建议在生产代码中使用这种写法。

#### 3.5 包内引用
如果是子包内的引用，可以按相对位置引入子模块 以 aa 包下的 module_AA 中导入 a包下内容为例：
from .. import module_A #..表示上级目录 .表示同级目录
from . import module_A2 #.表示同级目录

#### 3.6 sys.path 和模块搜索路径
当我们导入某个模块文件时， Python 解释器去哪里找这个文件呢？只有找到这个文件才能读取、装载运行该模块文件。
它一般按照如下路径寻找模块文件（按照顺序寻找，找到即停不继续往下寻找）：
    1. 内置模块
    2. 当前目录
    3. 程序的主目录
    4. pythonpath 目录（如果已经设置了 pythonpath 环境变量）
    5. 标准链接库目录
    6. 第三方库目录（site-packages 目录）
    7. .pth 文件的内容（如果存在的话）
    8. sys.path.append()临时添加的目录

当任何一个 python 程序启动时，就将上面这些搜索路径(除内置模块以外的路径)进行收集，放到 sys 模块的 path 属性中（sys.path）

· 使用 sys.path 查看和临时修改搜索路径
· pythonpath 环境变量的设置
    windows 系统中通过如下操作添加和设置 pythonpath 环境变量。
.pth 文件的写法
    我们可以在 site-packages 目录下添加.pth 文件。并在文件中增加内容： #一行一个目录

### 4. 模块发布和安装
#### 4.1 模块的本地发布
当我们完成了某个模块开发后，可以将他对外发布，其他开发者也可以以“第三方扩展库”的方式使用我们的模块。
我们按照如下步骤即可实现模块的发布：
1.为模块文件创建如下结构的文件夹（一般，文件夹的名字和模块的名字一样）：
2.在文件夹中创建一个名为『setup.py』的文件，内容如下：
    from distutils.core import setup
    setup(
        name='baizhanMath2', # 对外我们模块的名字
        version='1.0', # 版本号
        description='这是第一个对外发布的模块，测试哦', #描述
        author='gaoqi', # 作者
        author_email='gaoqi110@163.com', 
        py_modules=['baizhanMath2.demo1','baizhanMath2.demo2'] # 要发布的模块
    )
3. 构建一个发布文件。通过终端，cd 到模块文件夹 c 下面，再键入命令：
    python setup.py sdist
    执行完毕后，目录结构变为

#### 4.2 本地安装模块
将发布安装到你的本地计算机上。仍在 cmd 命令行模式下操作，进 setup.py 所在目录，键入命令：
    python setup.py install

安装成功后，我们进入 python 目录/Lib/site-packages 目录（第三方模块都安装的这里,python 解释器执行时也会搜索这个路径）：
安装成功后，直接使用 import 导入即可

#### 4.3 上传模块到 PyPI
将自己开发好的模块上传到 PyPI 网站上，将成为公开的资源，可以让全球用户自由使用。
按照如下步骤做，很容易就实现上传模块操作。

    注册 PyPI 网站
        注册 PyPI 网站：http://pypi.python.org

    ·创建用户信息文件.pypirc
        ·方式 1： 使用命令(适用 Linux)
            输入并执行后 python setup.py register ，然后输入用户名和密码，即可。
        ·方式 2：使用文件（适用 windows,Linux）
            在用户的家目录里创建一个文件名为.pypirc, 内容为：
                [distutils]
                index-servers=pypi
                [pypi]
                repository = https://upload.pypi.org/legacy/
                username = 账户名
                password = 你自己的密码
                
            【注】
            Linux 的家目录： ~/.pypirc
            Windows 的家目录是： c:/user/用户名
    ·上传并远程发布
        进入 setup.py 文件所在目录，使用命令“python setup.py sdist upload”，即可以将模块代码上传并发布：
    
    ·管理你的模块
        我们登录 pypi 官网，可以看到：
        如果你的模块已经上传成功，那么当你登录 PyPI 网站后应该能在右侧导航栏看到管理入口。

#### 4.4 让别人使用你的模块
模块发布完成后，其他人只需要使用 pip 就可以安装你的模块文件。比如：
    pip install package-name
如果你更新了模块，别人可以可以通过--update 参数来更新：
    pip install package-name update

### 5. 库(Library)
Python 中库是借用其他编程语言的概念，没有特别具体的定义。模块和包侧重于代码组织，有明确的定义。
一般情况，库强调的是功能性，而不是代码组织。我们通常将某个功能的“模块的集合”，称为库。

#### 5.1 标准库(Standard Library)
Python 拥有一个强大的标准库。Python 语言的核心只包含数字、字符串、列表、字典、文件等常见类型和函数，
而由 Python 标准库提供了系统管理、网络通信、文本处理、数据库接口、图形系统、XML 处理等额外的功能。

Python 标准库的主要功能有：
    1. 文本处理，包含文本格式化、正则表达式匹配、文本差异计算与合并、Unicode 支持，二进制数据处理等功能
    2. 文件处理，包含文件操作、创建临时文件、文件压缩与归档、操作配置文件等功能
    3. 操作系统功能，包含线程与进程支持、IO 复用、日期与时间处理、调用系统函数、日志（logging）等功能
    4. 网络通信，包含网络套接字，SSL 加密通信、异步网络通信等功能
    5. 网络协议，支持 HTTP，FTP，SMTP，POP，IMAP，NNTP，XMLRPC 等多种网络协议，并提供了编写网络服务器的框架
    6. W3C 格式支持，包含 HTML，SGML，XML 的处理
    7. 其它功能，包括国际化支持、数学运算、HASH、Tkinter 等

#### 5.2 第三方扩展库的介绍
强大的标准库奠定了 python 发展的基石，丰富和不断扩展的第三方库是 python 壮大的保证。我们可以进入 PyPI 官网：
表 常用第三方库大汇总

#### 5.3 PyPI 网站和 PIP 模块管理工具
PyPI(Python Package Index)是 python 官方的第三方库的仓库，所有人都可以下载第三方库或上传自己开发的库到 PyPI。PyPI 推荐使用 pip 包管理器来下载第三方库。

#### 5.4 安装第三方扩展库的 2 种方式

第一种方式：命令行下远程安装
    以安装第三方 pillow 图像库为例，在命令行提示符下输入：pip install pillow
    安装完成后，我们就可以开始使用。
    安装完，输入 pip show pillow， 进行确认：

第二种方式：Pycharm 中直接安装到项目中
    在 Pycharm 中，依次点击：file-->setting-->Project 本项目名-->Project Interpreter

## 第八章 文件操作(IO 技术)

### 文本文件和二进制文件
按文件中数据组织形式，我们把文件分为文本文件和二进制文件两大类。
1. 文本文件
    文本文件存储的是普通“字符”文本，python 默认为 unicode 字符集（两个字节表示一个字符，最多可以表示：65536 个），可以使用记事本程序打开。

2. 二进制文件
    二进制文件把数据内容用“字节”进行存储，无法用记事本打开。必须使用专用的软件解码。常见的有：MP4 视频文件、MP3 音频文件、JPG 图片、doc 文档等等。

### 文件操作相关模块概述
Python 标准库中，如下是文件操作相关的模块，我们会陆续给大家介绍。
名称 说明
io 模块             文件流的输入和输出操作 input output
os 模块             基本操作系统功能，包括文件操作
glob 模块           查找符合特定规则的文件路径名
fnmatch 模块        使用模式来匹配文件路径名
fileinput 模块      处理多个输入文件
filecmp 模块        用于文件的比较
cvs 模块            用于 csv 文件处理
pickle 和 cPickle   用于序列化和反序列化
xml 包              用于 XML 数据处理
bz2、gzip、zipfile、zlib、tarfile   用于处理压缩和解压缩文件（分别对应不同的算法）

#### 创建文件对象 open()
open()函数用于创建文件对象，基本语法格式如下：
    open(文件名[,打开方式])

如果只是文件名，代表在当前目录下的文件。文件名可以录入全路径，比如：D:\a\b.txt。
为了减少“\”的输入，可以使用原始字符串：r“d:\b.txt”。示例如下：
    f = open(r"d:\b.txt","w")
打开方式有如下几种：
模式    描述
r   读 read 模式
w   写 write 模式。如果文件不存在则创建；如果文件存在，则重写新内容；
a   追加 append 模式。如果文件不存在则创建；如果文件存在，则在文件末尾追加内容
b   二进制 binary 模式（可与其他模式组合使用）
+   读、写模式（可与其他模式组合使用）

文本文件对象和二进制文件对象的创建：
如果我们没有增加模式“b”，则默认创建的是文本文件对象，处理的基本单元是“字符”。
如果是二进制模式“b”，则创建的是二进制文件对象，处理的基本单元是“字节”。

### 文本文件的写入
#### 基本的文件写入操作
文本文件的写入一般就是三个步骤：
    1. 创建文件对象
    2. 写入数据
    3. 关闭文件对象

#### 常用编码介绍
在操作文本文件时，经常会操作中文，这时候就经常会碰到乱码问题。为了让大家有能力解决中文乱码问题，这里简单介绍一下各种编码之间的关系。

##### ASCII
全称为 American Standard Code for Information Interchange，美国信息交换标准代码，这是世界上最早最通用的单字节编码系统，主要用来显示现代英语及其他西欧语言。

ASCII 码用 7 位表示，只能表示 128 个字符。只定义了 27=128 个字符，用7bit 即可完全编码，而一字节 8bit 的容量是 256，所以一字节 ASCII 的编码最高位总是 0。

0～31 表示控制字符如回车、退格、删除等；
32～126 表示打印字符即可以通过键盘输入并且能显示出来的字符；
其中 48～57 为 0 到 9 十个阿拉伯数字，65～90 为 26 个大写英文字母，97～122 号为 26 个小写英文字母，
其余为一些标点符号、运算符号等，具体可以参考 ASCII 标准表。

##### ISO8859-1
ISO-8859-1 又称 Latin-1，是一个 8 位单字节字符集，它把 ASCII 的最高位也利用起来，并兼容了 ASCII，新增的空间是 128，但它并没有完全用完。在 ASCII 编码之上又增加了西欧语言、希腊语、泰语、阿拉伯语、希伯来语对应的文字符号，它是向下兼容 ASCII 编码

##### GB2312,GBK,GB18030
###### ·GB2312
GB2312 全称为信息交换用汉字编码字符集，是中国于 1980 年发布，主要用于计算机系统中的汉字处理。GB2312 主要收录了 6763 个汉字、682 个符号。
GB2312覆盖了汉字的大部分使用率，但不能处理像古汉语等特殊的罕用字，所以后来出现了像 GBK、GB18030 这种编码。
GB2312 完全兼容 ISO8859-1。
###### ·GBK
全称为 Chinese Internal Code Specification，即汉字内码扩展规范，于 1995 年制定。它主要是扩展了 GB2312，在它的基础上又加了更多的汉字，它一共收录了 21003 个汉字
###### ·GB18030
现在最新的内码字集于 2000 年发布，并于 2001 年强制执行，包含了中国大部分少数民族的语言字符，收录汉字数超过 70000 余个。
它主要采用单字节、双字节、四字节对字符编码，它是向下兼容 GB2312 和 GBK 的，虽然是我国的强制使用标准，但在实际生产中很少用到，用得最多的反而是 GBK 和 GB2312

##### Unicode
Unicode 编码设计成了固定两个字节，所有的字符都用 16 位(2^16=65536)表示，包括之前只占 8 位的英文字符等，所以会造成空间的浪费，UNICODE 在很长的一段时间内都没有得到推广应用。
Unicode 完全重新设计，不兼容 iso8859-1，也不兼容任何其他编码。

##### UTF-8
对于英文字母，unicode 也需要两个字节来表示。所以 unicode 不便于传输和存储。因此而产生了 UTF 编码，UTF-8 全称是（8-bit UnicodeTransformation Format）。
UTF 编码兼容 iso8859-1 编码，同时也可以用来表示所有语言的字符，不过，UTF 编码是不定长编码，每一个字符的长度从 1-4 个字节不等。其中，英文字母都是用一个字节表示，而汉字使用三个字节。

【老鸟建议】一般项目都会使用 UTF-8。unicode 中虽然汉字是两个字节，UTF-8 中汉字是 3 个字节。但是互联网中一个网页也包含了大量的英文字母，这些英文字母只占用 1 个字节，整体占用空间，UTF-8 仍然优于 Unicode。

#### 中文乱码问题
windows 操作系统默认的编码是 GBK，Linux 操作系统默认的编码是 UTF-8。当我们用 open()时，调用的是操作系统打开的文件，默认的编码是 GBK。
【示例】通过指定文件编码解决中文乱码问题

#### write()/writelines()写入数据
write(a)：把字符串 a 写入到文件中
writelines(b)：把字符串列表写入文件中，不添加换行符

#### close()关闭文件流
由于文件底层是由操作系统控制，所以我们打开的文件对象必须显式调用 close()方法关闭文件对象。当调用 close()方法时，首先会把缓冲区数据写入文件(也可以直接调用 flush()方法)，再关闭文件，释放文件对象。

为了确保打开的文件对象正常关闭，一般结合异常机制的 finally 或者 with 关键字实现无论何种情况都能关闭打开的文件对象。

#### with 语句(上下文管理器)
with 关键字（上下文管理器）可以自动管理上下文资源，不论什么原因跳出 with 块，都能确保文件正确的关闭，并且可以在代码块执行完毕后自动还原进入该代码块时的现场。

### 文本文件的读取
文件的读取一般使用如下三个方法：
    1. read([size])
        从文件中读取 size 个字符，并作为结果返回。如果没有 size 参数，则读取整个文件。读取到文件末尾，会返回空字符串。
    2. readline()
        读取一行内容作为结果返回。读取到文件末尾，会返回空字符串。
    3. readlines()
        文本文件中，每一行作为一个字符串存入列表中，返回该列表

### 二进制文件的读取和写入
二进制文件的处理流程和文本文件流程一致。首先还是要创建文件对象，不过，我们需要指定二进制模式，从而创建出二进制文件对象。
例如：
    f = open(r"d:\a.txt", 'wb') #可写的、重写模式的二进制文件对象
    f = open(r"d:\a.txt", 'ab') #可写的、追加模式的二进制文件对象
    f = open(r"d:\a.txt", 'rb') #可读的二进制文件对象

创建好二进制文件对象后，仍然可以使用 write()、read()实现文件的读写操作。

### 文件对象的常用属性和方法
文件对象封装了文件相关的操作。在前面我们学习了通过文件对象对文件进行读写操作。本节我们详细列出文件对象的常用属性和方法，并进行说明

#### 文件对象的属性
属性        说明
name    返回文件的名字
mode    返回文件的打开模式
closed  若文件被关闭则返回 True

#### 文件对象的打开模式
模式 说明
r 读模式
w 写模式
a 追加模式
b 二进制模式（可与其他模式组合）
+ 读写模式（可以其他模式组合）

#### 文件对象的常用方法
方法名 说明
read([size])    从文件中读取 size 个字节或字符的内容返回。若省略[size]，则读取到文件末尾，即一次读取文件所有内容
readline()      从文本文件中读取一行内容
readlines()     把文本文件中每一行都作为独立的字符串对象，并将这些对象放入列表返回
write(str)      将字符串 str 内容写入文件
writelines(s)   将字符串列表 s 写入文件文件，不添加换行符
seek(offset[,whence])   把文件指针移动到新的位置，offset 表示相对于 whence 的多少个字节的偏移量；
                            offset：
                                off 为正往结束方向移动，为负往开始方向移动
                            whence 不同的值代表不同含义：
                                0: 从文件头开始计算（默认值）
                                1：从当前位置开始计算
                                2：从文件尾开始计算
tell()              返回文件指针的当前位置
truncate([size])    不论指针在什么位置，只留下指针前 size 个字节的内容，其余全部删除；
                    如果没有传入 size，则当指针当前位置到文件末尾内容全部删除
flush()         把缓冲区的内容写入文件，但不关闭文件
close()         把缓冲区内容写入文件，同时关闭文件，释放文件对象相关资源

### 文件任意位置操作

### 使用 pickle 序列化
Python 中，一切皆对象，对象本质上就是一个“存储数据的内存块”。有时候，我们需要将“内存块的数据”保存到硬盘上，或者通过网络传输到其他的计算机上。这时候，就需要“对象的序列化和反序列化”。 对象的序列化机制广泛的应用在分布式、并行系统上。
序列化指的是：将对象转化成“串行化”数据形式，存储到硬盘或通过网络传输到其他地方。
反序列化是指相反的过程，将读取到的“串行化数据”转化成对象。
我们可以使用 pickle 模块中的函数，实现序列化和反序列操作。

序列化我们使用：
    pickle.dump(obj, file)  obj 就是要被序列化的对象，file 指的是存储的文件
    pickle.load(file)       从 file 读取数据，反序列化成对象

### CSV 文件的操作
csv(Comma Separated Values)是逗号分隔符文本格式，常用于数据交换、Excel文件和数据库数据的导入和导出。
与 Excel 文件不同，CSV 文件中：
    值没有类型，所有值都是字符串
    不能指定字体颜色等样式
    不能指定单元格的宽高，不能合并单元格
    没有多个工作表
    不能嵌入图像图表

Python 标准库的模块 csv 提供了读取和写入 csv 格式文件的对象。

#### csv.reader 对象和 csv 文件读取
【操作】csv.reader 对象于从 csv 文件读取数据

#### csv.writer 对象和 csv 文件写入
【操作】csv.writer 对象写一个 csv 文件

### os 和 os.path 模块
os 模块可以帮助我们直接对操作系统进行操作。我们可以直接调用操作系统的可执行文件、命令，直接操作文件、目录等等。在系统运维的核心基础。

#### os 模块-调用操作系统命令
·os.system 可以帮助我们直接调用系统的命令

【注】Linux 是命令行操作更容易，我们可以通过 os.system 可以更加容易的调用相关的命令；

·os.startfile：直接调用可执行文件

#### os 模块-文件和目录操作
我们可以通过前面讲的文件对象实现对于文件内容的读写操作。如果，还需要对文件和目录做其他操作，可以使用 os 和 os.path 模块。

##### os 模块下常用操作文件的方法
方法名 描述
remove(path)        删除指定的文件
rename(src,dest)    重命名文件或目录
stat(path)          返回文件的所有属性
listdir(path)       返回 path 目录下的文件和目录列表

##### os 模块下关于目录操作的相关方法，汇总如下：
方法名 描述
mkdir(path)                         创建目录
makedirs(path1/path2/path3/... )    创建多级目录
rmdir(path)                         删除目录
removedirs(path1/path2...)          删除多级目录
getcwd()                            返回当前工作目录：current work dir
chdir(path)                         把 path 设为当前工作目录
walk()                              遍历目录树
sep                                 当前操作系统所使用的路径分隔符

##### os.path 模块
os.path 模块提供了目录相关（路径判断、路径切分、路径连接、文件夹遍历）的操作
方法 描述
isabs(path)         判断 path 是否绝对路径
isdir(path)         判断 path 是否为目录
isfile(path)        判断 path 是否为文件
exists(path)        判断指定路径的文件是否存在
getsize(filename)   返回文件的大小
abspath(path)       返回绝对路径
dirname(p)          返回目录的路径
getatime(filename)  返回文件的最后访问时间
getmtime(filename)  返回文件的最后修改时间
walk(top,func,arg)  递归方式遍历目录
join(path,*paths)   连接多个 path
split(path)         对路径进行分割，以列表形式返回
splitext(path)      从路径中分割文件的扩展名

##### walk()递归遍历所有文件和目录
os.walk()方法：
返回一个 3 个元素的元组，(dirpath, dirnames, filenames), 
    dirpath：   要列出指定目录的路径
    dirnames：  目录下的所有文件夹
    filenames： 目录下的所有文件

### shutil 模块(拷贝和压缩)
shutil 模块是 python 标准库中提供的，主要用来做文件和文件夹的拷贝、移动、删除等；还可以做文件和文件夹的压缩、解压缩操作。
os 模块提供了对目录或文件的一般操作。shutil 模块作为补充，提供了移动、复制、压缩、解压等操作，这些 os 模块都没有提供。

### 递归算法
递归是一种常见的解决问题的方法，即把问题逐渐简单化。
递归的基本思想就是“自己调用自己”，一个使用递归技术的方法将会直接或者间接的调用自己。

利用递归可以用简单的程序来解决一些复杂的问题。比如：斐波那契数列的计算、汉诺塔、快排等问题。

递归结构包括两个部分：
     定义递归头。解答：什么时候不调用自身方法。如果没有头，将陷入死循环，也就是递归的结束条件。
     递归体。解答：什么时候需要调用自身方法。

递归的缺陷
简单的程序是递归的优点之一。但是递归调用会占用大量的系统堆栈，内存耗用多，在递归调用层次多时速度要比循环慢的多，所以在使用递归时要慎重。

## 第11章 GUI 图形用户界面编程
GUI（Graphics User Interface），即图形用户界面编程，我们可以通过 python 提供的丰富的组件，快速的实现使用图形界面和用户交互。

### 常用的 GUI 库
#### 1. Tkinter
tkinter（Tk interface）是 Python 的标准 GUI 库，支持跨平台的 GUI 程序开发。tkinter适合小型的 GUI 程序编写，也特别适合初学者学习 GUI 编程。本书以 tkinter 为核心进行讲解

#### 2. wxPython
wxPython 是比较流行的 GUI 库，适合大型应用程序开发，功能强于 tkinter，整体设计框架类似于 MFC(Microsoft Foundation Classes 微软基础类库)。

#### 3. PyQT
Qt 是一种开源的 GUI 库，适合大型 GUI 程序开发，PyQT 是 Qt 工具包标准的 Python 实现。我们也可以使用 Qt Desginer 界面设计器快速开发 GUI 应用程序。

#### tkinter 模块
本章中，涉及大量的 API 讲解。学习 API 最好的来源就是官方提供的文档：tkinter 官方网址：
https://docs.python.org/3.7/library/tk.html
或者：http://effbot.org/tkinterbook/ （相对规整，适合初学者查找）

### GUI 编程的核心步骤和第一个 GUI 程序
基于 tkinter 模块创建 GUI 程序包含如下 4 个核心步骤：
1. 创建应用程序主窗口对象（也称：根窗口）
    (1) 通过类 Tk 的无参构造函数
    from tkinter import *
    root = Tk()

2. 在主窗口中，添加各种可视化组件，比如：按钮（Button）、文本框（Label）等。
    btn01 = Button(root)
    btn01["text"] = "点我就送花"

3. 通过几何布局管理器，管理组件的大小和位置
    btn01.pack()

4. 事件处理
    (1) 通过绑定事件处理程序，响应用户操作所触发的事件（比如：单击、双击等）
    def songhua(e):
        messagebox.showinfo("Message","送你一朵玫瑰花，请你爱上我")
        print("送你 99 朵玫瑰花")

    btn01.bind("<Button-1>",songhua)

#### tkinter 主窗口
主窗口位置和大小
通过 geometry(‘wxh±x±y’)进行设置。
w 为宽度，h 为高度。+x 表示距屏幕左边的距离；-x 表示距屏幕右边的距离；+y 表示距屏幕上边的距离；-y 表示距屏幕下边的距离。

### GUI 编程整体描述
图形用户界面是由一个个组件组成，就像小孩“搭积木”一样最终组成了整个界面。有的组件还能在里面再放置其他组件，我们称为“容器”。Tkinter 的 GUI 组件关系图如下：

#### ·Misc 和 Wm：
Tkinter 的 GUI 组件有两个根父类，它们都直接继承了 object 类：
    ·Misc：它是所有组件的根父类。
    ·Wm：它主要提供了一些与窗口管理器通信的功能函数。

·Tk
    Misc 和 Wm 派生出子类 Tk，它代表应用程序的主窗口。一般应用程序都需要直接或间接使用 Tk。

·Pack、Place、Grid
    Pack、Place、Grid 是布局管理器。布局管理器管理组件的：大小、位置。通过布局管理器可以将容器中的组件实现合理的排布

·BaseWidget
    BaseWidget 是所有组件的父类

·Widget
    Widget 是所有组件类的父类。Widget 一共有四个父类：BaseWidget、Pack、Grid、Place。意味着，所有 GUI 组件同时具备这四个父类的属性和方法

【注】想观察类的层次结构可以在类定义处的类名上单击右键，选择 Diagram-->show Diagram。

#### 常用组件汇总列表
Tkinter 类 名称 简介
Toplevel    顶层     容器类，可用于为其他组件提供单独的容器；Toplevel 有点类似于窗口
Button  按钮       代表按钮组件
Canvas  画布       提供绘图功能，包括直线、矩形、椭圆、多边形、位图等
Checkbutton     复选框         可供用户勾选的复选框
Entry   单行输入框         用户可输入内容
Frame   容器        用于装载其它 GUI 组件
Label   标签        用于显示不可编辑的文本或图标
LabelFrame  容器      也是容器组件，类似于 Frame，但它支持添加标题
Listbox     列表框         列出多个选项，供用户选择
Menu    菜单      菜单组件
Menubutton  菜单按钮        用来包含菜单的按钮（包括下拉式、层叠式等）
OptionMenu  菜单按钮        Menubutton 的子类，也代表菜单按钮，可通过按钮打开一个菜单
Message     消息框     类似于标签，但可以显示多行文本；后来当 Label 也能显示多行文本之后，该组件基本处于废弃状态
PanedWindow     分区窗口        该容器会被划分成多个区域，每添加一个组件占一个区域，用户可通过拖动分隔线来改变各区域的大小
Radiobutton     单选钮         可供用户点边的单选钮
Scale   滑动条         拖动滑块可设定起始值和结束值，可显示当前位置的精确值
Spinbox     微调选择器       用户可通过该组件的向上、向下箭头选择不同的值
Scrollbar   滚动条         用于为组件（文本域、画布、列表框、文本框）提供滚动功能
Text    多行文本框       显示多行文本

### GUI 应用程序类的经

本节程序也是 GUI 应用程序编写的一个主要结构，采用了面向对象的方式，更加合理的组织代码。

通过类 Application 组织整个 GUI 程序，类 Application 继承了 Frame 及通过继承拥有了父类的特性。通过构造函数__init__()初始化窗口中的对象，通过 createWidgets()方法创建窗口中的对象。

Frame 框架是一个 tkinter 组件，表示一个矩形的区域。Frame 一般作为容器使用，可以放置其他组件，从而实现复杂的布局。

【示例】标准的 GUI 程序类的写法
"""测试一个经典的 GUI 程序的写法，使用面向对象的方式"""
from tkinter import *
from tkinter import messagebox

class Application(Frame):
    """一个经典的 GUI 程序的类的写法"""

    def __init__(self, master=None):
        super().__init__(master) # super()代表的是父类的定义，而不是父类对象
        self.master = master
        self.pack()
        self.createWidget()

    def createWidget(self):
        """创建组件"""
        self.btn01 = Button(self)
        self.btn01["text"] = "点击送花"
        self.btn01.pack()
        self.btn01["command"] = self.songhua
        
        # 创建一个退出按钮
        self.btnQuit = Button(self, text="退出", command=root.destroy)
        self.btnQuit.pack()

    def songhua(self):
        messagebox.showinfo("送花","送你 99 朵玫瑰花")

if __name__ == '__main__':
    root = Tk()
    root.geometry("400x100+200+300")
    root.title("一个经典的 GUI 程序类的测试")
    app = Application(master=root)
    root.mainloop()

### 简单组件
#### Label 标签
Label（标签）主要用于显示文本信息，也可以显示图像。
Label（标签）有这样一些常见属性：
1. width,height：
    用于指定区域大小，如果显示是文本，则以单个英文字符大小为单位(一个汉字宽度占2 个字符位置，高度和英文字符一样)；如果显示是图像，则以像素为单位。默认值是根据具体显示的内容动态调整。
2. font
    指定字体和字体大小，如：font = (font_name,size)
3. image:
    显示在 Label 上的图像，目前 tkinter 只支持 gif 格式。
4. fg 和 bg
    fg（foreground）:前景色、bg（background）:背景色
5. justify
    针对多行文字的对齐，可设置 justify 属性，可选值"left", "center" or "right"

#### Options 选项详解
我们可以通过三种方式设置 Options 选项，这在各种 GUI 组件中用法都一致。
    1. 创建对象时，使用可变参数
        fred = Button(self, fg="red", bg="blue")
    2. 创建对象后，使用字典索引方式
        fred["fg"] = "red"
        fred["bg"] = "blue"
    3. 创建对象后，使用 config()方法
        fred.config(fg="red", bg="blue")

如何查看组件的 Options 选项：
    1. 可以通过打印 config()方法的返回值，查看 Options 选项
        print(fred.config())
    2. 通过在 IDE 中，点击组件对象的构造方法，进入到方法内观察：

上面代码中有：“standard options 标准选项”和“widget-specific options 组件特定选项”。我们将常见的选项汇总如下：
选项名（别名） 含义
activebackground    指定组件处于激活状态时的背景色
activeforeground    指定组件处于激活状态时的前景色
anchor              指定组件内的信息（比如文本或图片）在组件中如何显示(当所在组件比信息大时，可以看出效果)。必须为下面的值之一：N、NE、E、SE、S、SW、W、NW 或 CENTER。比如 NW（NorthWest）指定将信息显示在组件的左上角
background(bg)      指定组件正常显示时的背景色
bitmap              指定在组件上显示该选项指定的位图，该选项值可以是 Tk_GetBitmap接收的任何形式的位图。位图的显示方式受 anchor、justify 选项的影响。如果同时指定了 bitmap 和 text，那么 bitmap 覆盖文本；如果同时指定了 bitmap 和 image，那么 image 覆盖 bitmap
borderwidth         指定组件正常显示时的 3D 边框的宽度，该值可以是 Tk_GetPixels 接收的任何格式
cursor              指定光标在组件上的样式。该值可以是 Tk_GetCursors 接受的任何格式
command             指定按组件关联的命令方法，该方法通常在鼠标离开组件时被触发调用
disabledforeground  指定组件处于禁用状态时的前景色
font                指定组件上显示的文本字体
foreground(fg)      指定组件正常显示时的前景色
highlightbackground 指定组件在高亮状态下的背景色
highlightcolor      指定组件在高亮状态下的前景色
highlightthickness  指定组件在高亮状态下的周围方形区域的宽度，该值可以是Tk_GetPixels 接收的任何格式
height              指定组件的高度，以 font 选项指定的字体的字符高度为单位，至少为1
image               指定组件中显示的图像，如果设置了 image 选项，它将会覆盖 text、bitmap 选项
justify             指定组件内部内容的对齐方式，该选项支持 LEFT（左对齐）、CENTER（居中对齐）或 RIGHT（右对齐）这三个值
padx                指定组件内部在水平方向上两边的空白，该值可以是 Tk_GctPixels 接收的任何格式
pady                指定组件内部在垂直方向上两地的空白，该值可以是 Tk_GctPixels 接收的任何格式
relief              指定组件的 3D 效果，该选项支持的值包括 RAISED、SUNKEN、FLAT、RIDGE、SOLID、GROOVE。该值指出组件内部相对于外部的外观样式，比如 RAISED 表示组件内部相对于外部凸起
selectbackground    指定组件在选中状态下的背景色
selectborderwidth   指定组件在选中状态下的 3D 边框的宽度，该值可以是 Tk_GetPixels接收的任何格式
selectforeground    指定组在选中状态下的前景色
state               指定组件的当前状态。该选项支持 NORMAL（正常）、DISABLE（禁用）这两个值
takefocus           指定组件在键盘遍历（Tab 或 Shift+Tab）时是否接收焦点，将该选项设为 1 表示接收焦点；设为 0 表示不接收焦点
text                指定组件上显示的文本，文本显示格式由组件本身、anchor 及justify 选项决定
textvariable        指定一个变量名，GUI 组件负责显示该变量值转换得到的字符串，文本显示格式由组件本身、anchor 及 justify 选项决定
underline           指定为组件文本的第几个字符添加下画线，该选项就相当于为组件绑定了快捷键
width               指定组件的宽度，以 font 选项指定的字体的字符高度为单位，至少为1
wraplength  对于能支持字符换行的组件，该选项指定每行显示的最大字符数，超过该数量的字符将会转到下行显示
xscrollcommand      通常用于将组件的水平滚动改变（包括内容滚动或宽度发生改变）与水平滚动条的 set 方法关联，从而让组件的水平滚动改变传递到水平滚动条
yscrollcommand      通常用于将组件的垂直滚动改变（包括内容滚动或高度发生改变）与垂直滚动条的 set 方法关联，从而让组件的垂直滚动改变传递到垂直滚动条

#### Button
Button（按钮）用来执行用户的单击操作。Button 可以包含文本，也可以包含图像。按钮被单击后会自动调用对应事件绑定的方法。

#### Entry 单行文本框
Entry 用来接收一行字符串的控件。如果用户输入的文字长度长于 Entry 控件的宽度时, 文字会自动向后滚动。如果想输入多行文本, 需要使用 Text 控件。

#### Text 多行文本框
Text(多行文本框)的主要用于显示多行文本，还可以显示网页链接, 图片, HTML 页面, 甚至 CSS样式表，添加组件等。因此，也常被当做简单的文本处理器、文本编辑器或者网页浏览器来使用。比如 IDLE 就是 Text 组件构成的。

·利用 Tags 实现更加强大的文本显示和控制
    Tags 通常用于改变 Text 组件中内容的样式和功能。你可以修改文本的字体、尺寸和颜色。另外，Tags 还允许你将文本、嵌入的组件和图片与鼠标和键盘等事件相关联。

#### Radiobutton 单选按钮
Radiobutton 控件用于选择同一组单选按钮中的一个。Radiobutton 可以显示文本，也可以显示图像

#### Checkbutton 复选按钮
Checkbutton 控件用于选择多个按钮的情况。Checkbutton 可以显示文本，也可以显示图像。

#### canvas 画布
canvas（画布）是一个矩形区域，可以放置图形、图像、组件等。

### 布局管理器
一个 GUI 应用程序必然有大量的组件，这些组件如何排布？这时候，就需要使用 tkinter提供的布局管理器帮助我们组织、管理在父组件中子组件的布局方式。tkinter 提供了三种管理器：pack、grid、place。

#### grid 布局管理器
grid 表格布局，采用表格结构组织组件。子组件的位置由行和列的单元格来确定，并且可以跨行和跨列，从而实现复杂的布局。

grid()方法提供的选项
选项          说明          取值范围
column      单元格的列号      从 0 开始的正整数
columnspan  跨列，跨越的列数    正整数
row         单元格的行号      从 0 开始的正整数
rowspan     跨行，跨越的行数    正整数
ipadx, ipady    设置子组件之间的间隔，x 方向或者 y 方向，默认单位为像素      非负浮点数，默认 0.0
padx, pady      与之并列的组件之间的间隔，x 方向或者 y 方向，默认单位是像素   非负浮点数，默认 0.0
sticky      组件紧贴所在单元格的某一角，对应于东南西北中以及 4 个角           “n”, “s”, “w”, “e”, “nw”, “sw”, “se”, “ne”, “center”(默认)

#### pack 布局管理器
pack 按照组件的创建顺序将子组件添加到父组件中，按照垂直或者水平的方向自然排布。如果不指定任何选项，默认在父组件中自顶向下垂直添加组件。
pack 是代码量最少，最简单的一种，可以用于快速生成界面。

pack()方法提供的选项
名称 描述 取值范围
expand  当值为“yes”时，side 选项无效。组件显示在父配件中心位置；若 fill 选项为”both”,则填充父组件
的剩余空间       “yes”, 自然数,”no”, 0（默认值”no”或 0）
fill    填充 x(y)方向上的空间，当属性 side=”top”或”bottom”时，填充 x 方向；当属性 side=”left”或”right”时，填充”y”方向；当 expand 选项为”yes”时，填充父组件的剩余空间   “x”, “y”, “both”，“none”(默认值为 none)
ipadx,ipady   设置子组件之间的间隔，x 方向或者 y 方向，默认单位为像素  非负浮点数，默认 0.0
padx,pady     与之并列的组件之间的间隔，x 方向或者 y 方向，默认单位是像素    非负浮点数，默认 0.0
side    定义停靠在父组件的哪一边上   “ top ” , “ bottom ” , “left”, “right”（默认为”top”）
before  将本组件于所选组建对象之前 pack，类似于先创建本组件再创建选定组件    已经 pack 后的组件对象
after   将本组件于所选组建对象之后 pack，类似于先创建选定组件再本组件   已经 pack 后的组件对象
in_     将本组件作为所选组建对象的子组件，类似于指定本组件的 master 为选定组件     已经 pack 后的组件对象
anchor    对齐方式，左对齐”w”，右对齐”e”，顶对齐”n”，底对齐     ”s”“n”, “s”, “w”, “e”, “nw”, “sw”, “se”, “ne”, “center”(默认)

【老鸟建议】如上列出了 pack 布局所有的属性，但是不需要挨个熟悉，了解基本的即可。pack 适用于简单的垂直或水平排布，如果需要复杂的布局可以使用 grid 或 place。

#### place 布局管理器
place 布局管理器可以通过坐标精确控制组件的位置，适用于一些布局更加灵活的场景。

place()方法的选项
选项 说明 取值范围
x,y     组件左上角的绝对坐标（相对于窗口）   非负整数    x 和 y 选项用于设置偏移（像素），如果同时设置relx(rely) 和 x(y)，那么 place 将优先计算 relx 和rely，然后再实现 x 和 y 指定的偏移值
relx    组件左上角的坐标（相对于父容器） relx 是相对父组件的位置。0 是最左边，0.5 是正中间，1是最右边；
rely    组件左上角的坐标（相对于父容器） rely 是相对父组件的位置。0 是最上边，0.5 是正中间，1
是最下边；
width,
height    组件的宽度和高度  非负整数
relwidth,
relheight    组件的宽度和高度（相对于父容器）    与 relx、rely 取值类似，但是相对于父组件的尺寸
anchor  对齐方式，左对齐”w”，右对齐”e”，顶对齐”n”，底对齐”s”    “n”, “s”, “w”, “e”, “nw”, “sw”, “se”, “ne”, “center”(默认)

### 事件处理
一个 GUI 应用整个生命周期都处在一个消息循环 (event loop) 中。它等待事件的发生，并
作出相应的处理。
Tkinter 提供了用以处理相关事件的机制. 处理函数可被绑定给各个控件的各种事件。
    widget.bind(event, handler)
如果相关事件发生, handler 函数会被触发, 事件对象 event 会传递给 handler 函数. 

#### 鼠标和键盘事件
代码 说明
<Button-1>
<ButtonPress-1>
<1>     鼠标左键按下。 2 表示右键，3 表示中键；
<ButtonRelease-1> 鼠标左键释放
<B1-Motion> 按住鼠标左键移动
<Double-Button-1> 双击左键
<Enter> 鼠标指针进入某一组件区域
<Leave> 鼠标指针离开某一组件区域
<MouseWheel> 滚动滚轮；
<KeyPress-a> 按下 a 键，a 可用其他键替代
<KeyRelease-a> 释放 a 键。
<KeyPress-A> 按下 A 键（大写的 A）
<Alt-KeyPress-a> 同时按下 alt 和 a；alt 可用 ctrl 和 shift 替代
<Double-KeyPress-a> 快速按两下 a
<Control-V> CTRL 和 V 键被同时按下，V 可以换成其它键位

event 对象常用属性
名称 说明
char 按键字符，仅对键盘事件有效
keycode 按键编码，仅对键盘事件有效
keysym 按键名称，仅对键盘事件有效
        比如按下空格键：
        键的 char： 键的 keycode：32 键的 keysym：space
        比如按下 a 键：
        键的 char：a 键的 keycode：65 键的 keysym：a
num 鼠标按键，仅对鼠标事件有效
type 所触发的事件类型
widget 引起事件的组件
width,height 组件改变后的大小，仅 Configure 有效
x，y 鼠标当前位置，相对于父容器
x_root,y_root 鼠标当前位置，相对于整个屏幕

#### lambda 表达式详解
lambda 表达式定义的是一个匿名函数，只适合简单输入参数，简单计算返回结果，不适合功能复杂情况
lambda 定义的匿名函数也有输入、也有输出，只是没有名字。语法格式如下：
    lambda 参数值列表：表达式

参数值列表即为输入。
表达式计算的结构即为输出

我们写一个最简单的案例：
    add3args = lambda x,y,z:x+y+z
    #print(add3args(10,20,30))

上面的 lambda 表达式相当于如下函数定义：
    def add3args(x,y,z):
        return x+y+z

lambda 表达式的参数值列表可以为如下内容：
lambda 格式 说明
lambda x, y: x*y    函数输入是 x 和 y，输出是它们的积 x*y
lambda:None         函数没有输入参数，输出是 None
lambda:aaa(3,4)         函数没有输入参数，输出是 aaa(3,4)的结果
lambda *args: sum(args) 输入是任意个数的参数，输出是它们的和
lambda **kwargs: 1      输入是任意键值对参数，输出是 1

我们在平时使用时，注意 lambda 只是一个匿名函数（没有名字的函数），功能不强，不要
过度使用；

#### 多种事件绑定方式汇总
·组件对象的绑定
    1. 通过 command 属性绑定（适合简单不需获取 event 对象）
        Button(root,text=”登录”,command=login)
    2. 通过 bind()方法绑定（适合需要获取 event 对象）
        c1 = Canvas(); c1.bind(“<Button-1>”,drawLine) 

·组件类的绑定
    调用对象的 bind_class 函数，将该组件类所有的组件绑定事件：
        w.bind_class(“Widget”,”event”,eventhanler)
    
    比如：btn01.bind_class(“Button”,”<Button-1>”,func)

### 其他组件

#### OptionMenu 选择项
OptionMenu(选择项)用来做多选一，选中的项在顶部显示。

#### Scale 移动滑块
Scale(移动滑块)用于在指定的数值区间，通过滑块的移动来选择值。

#### 颜色选择框
颜色选择框可以帮助我们设置背景色、前景色、画笔颜色、字体颜色等等。

#### 文件对话框
文件对话框帮助我们实现可视化的操作目录、操作文件。最后，将文件、目录的信息传入到程序中。
文件对话框包含如下一些常用函数：

函数名 对话框 说明
askopenfilename(**options)  文 件 对 话框     返回打开的文件名
askopenfilenames(**options)                 返回打开的多个文件名列表
askopenfile(**options)                      返回打开文件对象
askopenfiles(**options)                     返回打开的文件对象的列表
askdirectory(**options)     目 录 对 话框     返回目录名
asksaveasfile(**options)    保 存 对 话框       返回保存的文件对象
asksaveasfilename(**options)                返回保存的文件名

命名参数 options 的常见值如下：
参数名                 说明
defaultextension        默认后缀：.xxx    用户没有输入则自动添加
filetypes=[(label1,pattern1),(labe2,pattern2)]      文件显示过滤器
initialdir          初始目录
initialfile         初始文件
parent              父窗口，默认根窗口
title               窗口标题

#### 简单输入对话框
simpledialog(简单对话框)包含如下常用函数
函数名                         说明
askfloat(title,prompt,**kw)     输入并返回浮点数
askinteger(title,prompt,**kw)   输入并返回整数
askstring(title,prompt,**kw)    输入并返回字符串

参数中，title 表示窗口标题；prompt 是提示信息；命名参数 kw 为各种选项：initialvalue（初始值）、minvalue（最小值）、maxvalue（最大值）。

#### 通用消息框
messagebox（通用消息框）用于和用户简单的交互，用户点击确定、取消。
如下列出了messagebox 的常见函数：
函数名 说明 例子
askokcancel(title,message,**options)        OK/Cancel 对话框
askquestion(title,message,**options)        Yes/No 问题对话框
askretrycancel(title,message,**options)     Retry/Cancel问题对话框
showerror(title,message,**options)          错误消息对话框
showinfo(title,message,**options)           消息框
showwarning(title,message,**options)        警告消息框

#### ttk 子模块控件
我们再前面学的组件是 tkinter 模块下的组件，整体风格较老较丑。为了弥补这点不足，推出了 ttk 组件。ttk 组件更加美观、功能更加强大。 新增了 LabeledScale(带标签的Scale)、Notebook(多文档窗口)、Progressbar(进度条)、Treeview(树)等组件。

使用 ttk 组件与使用普通的 Tkinter 组件并没有多大的区别，只要导入 ttk 模块即可。

【注】此处我们不展开细讲 ttk。如果你的项目确实需要用到复杂的界面，推荐大家使用wxpython 或者 pyQt.

#### 菜单
GUI 程序通常都有菜单，方便用户的交互。我们一般将菜单分为两种：
1. 主菜单
    主菜单通常位于 GUI 程序上方。例如：

2. 快捷菜单（上下文菜单）
    通过鼠标右键单击某个组件对象而弹出的菜单，一般是与该组件相关的操作。

##### 主菜单
主菜单一般包含：文件、编辑、帮助等，位于 GUI 窗口的上面。创建主菜单一般有如下 4步：
1. 创建主菜单栏对象
    menubar = tk.Menu(root)
2. 创建菜单，并添加到主菜单栏对象
    file_menu = tk.Menu(menubar)
    menubar.add_cascade(label=”文件”,menu=file_menu)
3. 添加菜单项到 2 步中的菜单
    file_menu.add_command(label=”打开”)
    file_menu.add_command(label=”保存”,accelerator=”^p” command=mySaveFile)
    file_menu.add_separator()
    file_menu.add_command(label=”退出”)
4. 将主菜单栏添加到根窗口
    root[“menu”]=menubar

##### 上下文菜单
快捷菜单（上下文菜单）是通过鼠标右键单击组件而弹出的菜单，一般是和这个组件相关的操作，比如：剪切、复制、粘贴、属性等。
创建快捷菜单步骤如下：

1. 创建菜单
    menubar = tk.Menu(root)
    menubar.add_command(label=”字体”)
2. 绑定鼠标右键单击事件
    def test(event):
        menubar.post(event.x_root,event.y_root) #在鼠标右键单击坐标处显示菜单
    root.bind(“<Button-3>”,test)






# Python 教程

Python 是一种易于学习又功能强大的编程语言。它提供了高效的高级数据结构，还能简单有效地面向对象编程。Python 优雅的语法和动态类型，以及解释型语言的本质，使它成为多数平台上写脚本和快速开发应用的理想语言。

Python 解释器易于扩展，可以使用 C 或 C++（或者其他可以通过 C 调用的语言）扩展新的功能和数据类型。Python 也可用于可定制化软件中的扩展程序语言。

这个教程非正式地介绍了 Python 语言和系统的基本概念和功能。最好在阅读的时候准备一个 Python 解释器进行练习。所有的例子都是相互独立的，所以这个教程也可以离线阅读。

这个教程并没有完整地介绍每一个功能，甚至可能没有涉及全部的常用功能。这个教程只介绍 Python 中最值得注意的功能，也会让你体会到这个语言的风格特色。学习完这个教程，你将可以阅读和编写 Python 模块和程序，也可以开始学习 Python 标准库。

术语对照表 也很值得一读。

##    1. 课前甜点

Python很容易使用，但它是一种真正的编程语言，提供了很多数据结构，也支持大型程序。
Python 允许你划分程序模块，在其他的 Python 程序中重用。
Python是一种解释型语言，不需要编译和链接。
Python程序的书写是紧凑而易读的。
Python是“可扩展的”

##    2. 使用 Python 解释器
###        2.1. 调用解释器
通过命令启动Python 解释器
py
python3
在主提示符中输入文件结束字符（在 Unix 系统中是 Control-D，Windows 系统中是 Control-Z）就退出解释器并返回退出状态为0。
如果这样不管用，你还可以写这个命令退出：quit()。
另一种启动解释器的方式是 python -c command [arg] ...，其中 command 要换成想执行的指令，就像命令行的 -c 选项。
由于 Python 代码中经常会包含对终端来说比较特殊的字符，通常情况下都建议用英文单引号把 command 括起来。
有些 Python 模块也可以作为脚本使用。可以这样输入：python -m module [arg] ...，这会执行 module 的源文件，就跟你在命令行把路径写全了一样。
在运行脚本的时候，有时可能也会需要在运行后进入交互模式。这种时候在文件参数前，加上选项 -i 就可以了。
####            2.1.1. 传入参数
如果可能的话，解释器会读取命令行参数，转化为字符串列表存入 sys 模块中的 argv 变量中。执行命令 import sys 你可以导入这个模块并访问这个列表。这个列表最少也会有一个元素；如果没有给定输入参数，sys.argv[0] 就是个空字符串。如果脚本名是标准输入，sys.argv[0] 就是 '-'。使用 -c command 时，sys.argv[0] 就会是 '-c'。如果使用选项 -m module，sys.argv[0] 就是包含目录的模块全名。在 -c command 或 -m module 之后的选项不会被解释器处理，而会直接留在 sys.argv 中给命令或模块来处理。
####            2.1.2. 交互模式
在终端（tty）输入并执行指令时，我们说解释器是运行在 交互模式（interactive mode）。在这种模式中，它会显示 主提示符（primary prompt），提示输入下一条指令，通常用三个大于号（>>>）表示；连续输入行的时候，它会显示 次要提示符，默认是三个点（...）。进入解释器时，它会先显示欢迎信息、版本信息、版权声明，然后就会出现提示符
###        2.2. 解释器的运行环境
####            2.2.1. 源文件的字符编码
##    3. Python 的非正式介绍
###        3.1. Python 作为计算器使用
####            3.1.1. 数字
####            3.1.2. 字符串
####            3.1.3. 列表
###        3.2. 走向编程的第一步
##    4. 其他流程控制工具
###        4.1. if 语句
###        4.2. for 语句
###        4.3. range() 函数
###        4.4. break 和 continue 语句，以及循环中的 else 子句
###        4.5. pass 语句
###        4.6. 定义函数
###        4.7. 函数定义的更多形式
####            4.7.1. 参数默认值
####            4.7.2. 关键字参数
####            4.7.3. 特殊参数
#####                4.7.3.1. 位置或关键字参数
#####                4.7.3.2. 仅限位置参数
#####                4.7.3.3. 仅限关键字参数
#####                4.7.3.4. 函数示例
#####                4.7.3.5. 概括
####            4.7.4. 任意的参数列表
####            4.7.5. 解包参数列表
####            4.7.6. Lambda 表达式
####            4.7.7. 文档字符串
####            4.7.8. 函数标注
###        4.8. 小插曲：编码风格
##    5. 数据结构
###        5.1. 列表的更多特性
####            5.1.1. 列表作为栈使用
####            5.1.2. 列表作为队列使用
####            5.1.3. 列表推导式
####            5.1.4. 嵌套的列表推导式
###        5.2. del 语句
###        5.3. 元组和序列
###        5.4. 集合
###        5.5. 字典
###        5.6. 循环的技巧
###        5.7. 深入条件控制
###        5.8. 序列和其它类型的比较
##    6. 模块
###        6.1. 有关模块的更多信息
####            6.1.1. 以脚本的方式执行模块
####            6.1.2. 模块搜索路径
####            6.1.3. “编译过的”Python文件
###        6.2. 标准模块
###        6.3. dir() 函数
###        6.4. 包
####            6.4.1. 从包中导入 *
####            6.4.2. 子包参考
####            6.4.3. 多个目录中的包
##    7. 输入输出
###        7.1. 更漂亮的输出格式
####            7.1.1. 格式化字符串文字
####            7.1.2. 字符串的 format() 方法
####            7.1.3. 手动格式化字符串
####            7.1.4. 旧的字符串格式化方法
###        7.2. 读写文件
####            7.2.1. 文件对象的方法
####            7.2.2. 使用 json 保存结构化数据
##    8. 错误和异常
###        8.1. 语法错误
###        8.2. 异常
###        8.3. 处理异常
###        8.4. 抛出异常
###        8.5. 用户自定义异常
###        8.6. 定义清理操作
###        8.7. 预定义的清理操作
##    9. 类
###        9.1. 名称和对象
###        9.2. Python 作用域和命名空间
####            9.2.1. 作用域和命名空间示例
###        9.3. 初探类
####            9.3.1. 类定义语法
####            9.3.2. 类对象
####            9.3.3. 实例对象
####            9.3.4. 方法对象
####            9.3.5. 类和实例变量
###        9.4. 补充说明
###        9.5. 继承
####            9.5.1. 多重继承
###        9.6. 私有变量
###        9.7. 杂项说明
###        9.8. 迭代器
###        9.9. 生成器
###        9.10. 生成器表达式
##    10. 标准库简介
###        10.1. 操作系统接口
###        10.2. 文件通配符
###        10.3. 命令行参数
###        10.4. 错误输出重定向和程序终止
###        10.5. 字符串模式匹配
###        10.6. 数学
###        10.7. 互联网访问
###        10.8. 日期和时间
###        10.9. 数据压缩
###        10.10. 性能测量
###        10.11. 质量控制
###        10.12. 自带电池
##    11. 标准库简介 —— 第二部分
###        11.1. 格式化输出
###        11.2. 模板
###        11.3. 使用二进制数据记录格式
###        11.4. 多线程
###        11.5. 日志
###        11.6. 弱引用
###        11.7. 用于操作列表的工具
###        11.8. 十进制浮点运算
##    12. 虚拟环境和包
###        12.1. 概述
###        12.2. 创建虚拟环境
###        12.3. 使用pip管理包
##    13. 接下来？
##    14. 交互式编辑和编辑历史
###        14.1. Tab 补全和编辑历史
###        14.2. 默认交互式解释器的替代品
##    15. 浮点算术：争议和限制
###        15.1. 表示性错误
##    16. 附录
###        16.1. 交互模式
####            16.1.1. 错误处理
####            16.1.2. 可执行的Python脚本
####            16.1.3. 交互式启动文件
####            16.1.4. 定制模块

