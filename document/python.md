# Head First Python
## 引子
你的大脑与Python
### 谁适合看这本书？
### 我们知道你在想什么
### 我们也知道你的大脑正在想什么
### 元知识：有关思考的思考
### 我们是这么做的
### 重要说明
### 致谢
## 1 基础知识：快速入门
尽快开始Python编程
### 了解IDLE的窗口
### 执行代码，一次执行一条语句
### 函数 + 模块 = 标准库
### 数据结构是内建的
### 调用方法包含结果
### 决定什么时候去年代码块
### 对应“if”可以有什么“else”？
### 代码组可以包含嵌套代码组
我们已经知道些什么
    Python提供了一个内置IDE，名为IDLE，允许创建、编辑和运行Python代码，你要做的就是输入代码、保存然后按F5运行。
    IDLE与Python解释器交互，解释器会为你自动完成编译——>链接——>运行过程，这使你能够集中精力编写你的代码。
    解释器从上到下运行（存储在一个文件中的）代码，一次执行一行。Python中没有main()函数/方法的概念。
    Python提供了一个强大的标准库，允许你访问大量可重用的模块（datetime只是其中一个例子）。
    编写Python程序时，可以使用一组标准数据结构。列表是其中之一，这与数组的概念很类似。
    不需要声明一个变量的类型，在Python中为一个变量赋值时，它会自动取相应数据的类型。
    可以在if/elif/else语句完成判定，if,elif和else关键字放在代码块前面，在Python中代码块称为“代码组”。
    代码组很容易发现，因为它们总是缩进的，缩进是Python提供的唯一的代码分组机制。
    除了缩进，代码组前面还可以有一个冒号(:)，这是Python语言的一个语法要求。
### 回到 Python Shell
### 在 Shell 上试验
### 迭代处理一个对象序列
### 迭代指定的次数
### 在代码中应用任务1的成果
### 让执行暂停
### 用Python 生成随机整数
### 编写一个正式的商店应用
### 缩进是不是让你抓狂？
### 向解释器请求一个函数的帮助文档
### Range 试验
### 第1章的代码
## 2 列表数据：处理有序数据
所有程序都会处理数据，Python程序也不例外
### 数字、字符串和对象
### 认识4个内置数据结构
### 无序数据结构：字典
### 一种避免重复的数据结构：集合
### 按字面创建列表
### 有多行代码时使用编辑器
### 在运行时“扩展”列表
### 用“in”检查成员关系
### 从列表删除对象
### 用对象扩展列表
### 在列表中插入一个对象
### 如何复制一个数据结构
### 列表扩展中括号记法
### 列表认识开始、结束和步长值
### 开始和结束列表
### 在列表中使用切片
### Python的"for"循环了解列表
### Marvin切片详解
### 什么时候不使用列表
### 第2章的代码
## 3 结构化数据：处理结构化数据
Python的列表数据结构很棒，不过它不是万能的
### 字典存储键/值对
### 如何发现代码中的字典
### 不会维持插入顺序
### 用中括号查找值
### 运行时处理字典
### 更新频度计数器
### 迭代处理字典
### 迭代处理键和值
### 用"items"迭代处理字典
### 字典有多动态？
### 避免运行时出现KetError
### 用"in"检查成员关系
### 使用前确保初始化
### 用"not in"替换"in"
### 使用"setdefault"方法
### 高效创建集合
### 充分利用集合方法
### 元组的意义
### 结合内置数据结构
### 访问一个复杂数据结构的数据
### 第3章的代码
## 4 代码重用：函数与模块
重用代码是构建一个可维护的系统的关键。
### 利用函数重用代码
### 引入函数
### 调用你的函数
### 函数可以接收参数
### 返回一个值
### 返回多个值
### 回忆内置数据结构
### 建立一个通用的函数
### 创建另一个函数
### 为参数指定默认值
### 位置赋值与关键字赋值
### 更新已经知道的函数知识
### 从命令行运行Python
### 创建必要的安装文件
### 创建发布文件
### 用"pip"安装包
### 展示按值调用语义
### 展示按引用调用语义
### 安装测试开发工具
### 我们的代码PEP 8兼容性如何？
### 理解错误消息
### 第4章的代码
## 5 构建一个Web应用：来真格的
现阶段你已经掌握了足够多的Python知识，可以放心地构建应用了。
### Python：你已经知道些什么
### 我们希望Web应用做什么？
### 安装Flask
### Flask如何工作？
### 第一次运行Flask Web应用
### 创建一个Flask Web应用对象
### 用URL修饰函数
### 运行Web应用的行为
### 为Web提供功能
### 构建HTML表单
### 模板与Web页面相关
### 从Flask呈现模板
### 显示Web应用的HTML表单
### 准备运行模板代码
### 了解HTTP状态码
### 处理提交的数据
### 改进编辑/停止/启动/测试循环
### 用Flask访问HTML表单数据
### 在Web应用中使用请求数据
### 结果生成为HTML
### 准备把你的Web应用部署到云
### 第5章的代码
## 6 存储和管理数据：数据放在哪里
迟早需要把你的数据安全地存储在某个地方。
### 用Web应用的数据做些什么
### Python支持打开、处理和关闭文件
### 从现有的文件读取数据
### 比”打开、处理、关闭“更好的”with“
### 通过你的Web应用查看日志
### 通过查看源代码检查原始数据
### 现在来转义（你的数据）
### 在Web应用中查看整个日志
### 记录特定的Web请求属性
### 记录单行分隔数据
### 从原始数据到可读的输出
### 有HTML生成可读的输出
### 在模板中嵌入显示逻辑
### 用Jinja2生成可读的输出
### Web应用代码的当前状态
### 关于数据的问题
### 第6章代码
## 7 使用数据库：具体使用Python的DB-API
把数据存储在关系数据库系统很方便
### 基于数据库的Web应用
### 任务1:安装MySQL服务器
### 引入Python的DB-API
### 任务2:为Python安装一个MySQL数据库的驱动程序
### 安装MySQL Connector/Python
### 任务3:创建Web应用的数据库和表
### 确定日志数据的结构
### 确认表可以存放数据
### 任务4:创建代码处理Web应用的数据库和表
### 存储数据只是问题的一半
### 如何最好地重用你的数据库代码？
### 考虑你想重用什么
### 那个Import呢？
### 你以前已经见过这个模式
### 坏消息并没有那么糟糕
### 第7章的代码
## 8 一点点类：抽象行为和状态
类允许把代码行为和状态打包在一起
### 挂接到"with"语句
### 面向对象入门
### 由类创建对象
### 对象共享行为，但不共享状态
### 用Cou ntFromBy做更多事情
### 调用方法：理解细节
### 为类增加方法
### “self”的重要性
### 处理作用域
### 属性名前加"self"
### 使用之前初始化（属性）值
### Dunder "init" 初始化属性
### 用Dunder "init" 初始化属性
### 理解CountFromBy的表示
### 定义CountFromBy的表示
### 为CountFromBy提供合理的默认值
### 类：我们知道些什么
### 第8章的代码
## 9 上下文管理协议：挂接Python的with语句
现在该将你所学派上用场了
### 要共享这个Web应用的数据库代码，哪种方法最好
### 用方法管理上下文
### 你已经见过上下文管理器的使用
### 创建一个新的上下文管理器类
### 用数据库配置初始化类
### 用Dunder "enter" 完成建立
### 用Dunder "exit" 完成清理
### 重新考虑你的Web应用代码
### 回忆 "log_request" 函数
### 修改 "log_request" 函数
### 回忆 "view_the_log" 函数
### 不只是代码改变
### 修改 "view_the_log" 函数
### 回答数据问题
### 第9章的代码
## 10 函数修饰符：包装函数
要增强你的代码，第9章的上下文管理协议并不是全部
### Web服务器（而不是你的计算机）运行代码
### Flask的会话技术增加状态
### 字典查找获取状态
### 用会话管理登录
### 完成注销和状态检查
### 向函数传递一个函数
### 调用传入的函数
### 接收一个参数列表
### 处理参数字典
### 接收任意数量和类型的函数参数
### 创建函数修饰符
### 最后一步：处理参数
### 使用修饰符
### 再来限制对/viewlog的访问
### 第10章的代码
## 11 异常处理：出问题了怎么办
问题总有可能发生，不论你的代码有多好
### 数据库并不总是可用
### Web攻击是个棘手的问题
### 输入输出（有时）很慢
### 函数调用可能失败
### 用try执行容易出错的代码
### try一次，except多次
### 捕获所有异常的异常处理器
### 从”sys“了解异常
### 再来看捕获所有异常的异常处理器
### 回到我们的Web应用代码
### 安静地处理异常
### 处理其他数据库错误
### 避免紧耦合的代码
### 再看DBcm模块
### 创建定制异常
### ”DBcm“还会有什么问题？
### 处理SQLError有所不同
### 产生一个SQLError
### 简要回顾：增加健壮性
### 如何处理待会？这要看具体情况……
### 第11章的代码
## 11 3/4 关于线程：处理等待
你的代码有时要花很长时间执行
### 等待：怎么办？
### 如何查询数据库
### 数据库INSTERT和SELECT是不同的
### 一次完成多个工作
### 别郁闷：使用线程
### 最重要的是：不要惊慌
### 别郁闷：Flask能帮忙
### 现在这个Web应用健壮吗？
### 第11 3/4章的代码
## 12 高级迭代：疯狂地循环
我们的程序往往会在循环上花大量时间
### CSV数据读取为列表
### CSV数据读取为字典
### 去除空白符然后分解原始数据
### 串链方法调用时要当心
### 将数据转换为你需要的格式
### 转换为列表字典
### 发现列表的模式
### 将模式转换为推导式
### 仔细研究推导式
### 指定一个字典推导式
### 用过滤扩展推导式
### 用Python的方式处理复杂性
### 集合推导式的实际使用
### 关于”元组推导式“?
### 代码周围加小括号 == 生成器
### 使用列表推导式处理URL
### 使用生成器处理URL
### 定义你的函数要做什么
### 生成器函数中使用yield
### 跟踪生成器函数
### 最后一个问题
### 第12章的代码
## 附录A安装：安装Python
首要的事情：在你的计算机上安装Python
## 附录B Pythonanywhere：部署你的Web应用
在第5章的最后，我们说过只需要10分钟就可以把你的Web应用部署到云
## 附录C我们没有介绍的十大内容：还有更多需要学习
### 1.关于Python 2？
### 2.虚拟编程环境
### 3.关于面向对象的更多内容
### 4.字符串的格式
### 5.排序
### 6.更多标准库特性
### 7.并发运行你的代码
### 8.Tkinter提供GUI（以及使用Turtles）
### 9.测试之前不会结束
### 10.调试，调试，再调试
## 附录D我们没有介绍的十大项目：更多工具、库和模块
### 1.>>>的替代工具
### 2.IDLE的替代工具
### 3.Jupyter Notebook：基于Web的IDE
### 4.关于数据科学
### 5.Web开发技术
### 6.处理Web数据
### 7.更多数据源
### 8.编程工具
### 9.Kivy：我们见过的”最酷的项目“
### 10.替代实现
## 附录E多参与：Python社区
Python不只是一个很好的编程语言
## 索引


# 【尚学堂·百战程序员】
程序员修炼手册
一：学会观察这个世界
二：学会学习，再去学习
    守
        刚开始学习，首先要做到对老师和知识的“敬畏之心”。学习就要先信服老师，不服老师就别学。
        守”就是一心遵守老师的教诲，守住招式，反复练习.这 才 是最基本、也是最重要的阶段。
    破
        在试错过程中发挥自己的独创。开始“突破”老师的教诲，开始有自己的思考。
    离
        离”就是通过不断的思考和反复的练习，一点点“破”，最后形成了自己的风格。“脱离”老师开始讲的“招式”，升华成为“专家”。
三：要动手，实战吧
    无论如何，请坚持不懈的动手实战！
    不管是 学习编程， 还是 学习 其他 任何技术，一定要动手，仅仅靠看和听是学不好编程的。
四：建立体系为先，不纠结，不事事求完美
    对待人生的任何事情都要：抓大放小，要事为先。
    任何事情都要追求完美才敢继续往后进行，是一种性格缺陷。大胆的放弃一些东西吧，有失才有得，把自己有限的、宝贵的精力用在对于就业直接相关的地方，这才是最有效率的学习方式！ 
五：什么是高手
    想成为高手，先建立“知识体系”，再根据需要去钻研某些细节。
    当你看书到某个地方暂时不理解的时候，暂时放手吧，追求一些行云流水、自然而然的境界吧，只是不要停下前进的脚步，不要被大路旁边的支根末节干扰了你前进的行程，项目，真实的项目，这才是目的。
六：问题解决之道（会提问、会搜索）
    1、要仔细观察错误的现象。不要随便问人
    2、仔细思考问题会出在哪些环境（重要）
    3、如何定位错误（重要） 分析清楚有哪些环境之后，下一步就是定位到底什么环境出错了。
    4、如果还不行，搜索吧
        先精后粗，首先先尽量精确的查找 。
    5、什么？还不行？那么就BBS和QQ群吧
七：项目的自学

培训四个作用是自学无法满足的：
    A：系统化知识
    B：真实项目锻炼经验
    C：少走弯路，节省时间
    D: 形成师生朋友圈

# 【尚学堂·百战程序员】python400集
## Python入门
### 第一个Python程序中需要注意的小要点：
   1、不要在程序中，行开头处增加空格，空格在Python中有缩进的含义。
   2、符号都是英文符号，不是中文。比如（“


### 程序基本格式
 1、恰当的空格，缩进问题
    (1)、逻辑行首的空白（空格和制表符）用来决定逻辑行首的缩进层次，从而用来决定语句的分组
    （2）、语句从新行的第一列开始。
    （3）、缩进风格统一：
        a、每个缩进层次全程，单个制表符或四个空格（IDE会自动将制表符设置成4个空格）
        b、Python用缩进而不是{}表示程序块
2、Python区分大小写
3、注释
    （1）、行注释
        每行注释前加#号。当解释器看到#,则忽略这一行#后面的内容
    （2）、段注释
        使用三个连续单引号（'''）。当解释器看到'''时，则会扫描到下一个‘’‘，然后忽略他们之间的内容

开始学习图形化程序设计

## 内置数据类型
### Python程序的构成
1、Python程序同模块组成。一个模块对应Python源文件，一般后缀名是：.py
2、模块由语句组成。运行Python程序时，按照模块中的语句的顺序依次执行。
3、语句是Python程序的构造单元，用于创建对象、变量赋值、调用函数、控制语句等。

#### 代码的组织和缩进
#### 使用注释#
#### 使用\行连接符

### 对象
Python中，一切皆对象。每个对象由：标识(identity)、类型(type)、值(value)组成。
    1、标识用于唯一标识对象，通常对应于对象在计算机内存中的地址。使用内置函数id(obj)可返回对象obj的标识
    2、类型用于表示对象存储的“数据“的类型。类型可以限制对象的取值范围以及要执行的操作。可以使用type(obj)获得对象的所属类型。
    3、值表示对象所存储的数据的信息。使用print(obj)可以直接打印出值。
对象的本质就是：一个内存块，拥有特定的值，支持特定类型的相关操作。

### 引用
在Python中，变量也成为：对象的引用。因为变量存储的就是对象的地址。
变量通过地址引用了”对象“。
变量位于：栈内存。
对象位于：堆内存。
Python是动态类型语言
变量不需要显式的声明类型。根据变量引用的对象，Python解释器自动确定数据类型。
Python是强类型语言
每个对象都有数据类型，只支持该类型支持的操作。

### 标识符
基本用法
标识符：用于变量、函数、类、模块等的名称。标识符有如下特定的规则
1、区分大小写。
2、第一个字符必须是字母、下划线。其后的字符是：字母、数字、下划线
3、不能使用关键字。
4、以双开线开头和结尾的名称通常有特殊含义

#### Python标识符命名规则
类型    规则    
模块和包名  全小写字母，尽量简单。苦多个单词之间用下划线
函数名      全小写字母，多个单词之间用下划线隔开
类名        首字母大写，采用驼峰原则。多个单词时，每个单词第一个字母大写，其余部分小写
常量名      全大写字母，多个单词用下划线隔开

#### 变量和简单赋值语句
变量的声明和赋值
变量名 = 表达式
变量在使用前必须先被初始化（先被赋值）

#### 删除变量和垃圾回收机制
可以使用del语句删除不再使用的变量。
如果对象没有变量引用，就会被垃圾回收器回收，清空内存空间。

#### 链式赋值
用于同一个对象赋值给多个变量

#### 系列解包赋值
系列数据赋值给对应相同个数的变量（个数必须保持一致）
a,b,c=4,5,6 相当于：a=4;b=5;c=6
a,b=b,a

#### 常量
Python不支持常量，即没有语法规则限制改变一个常量的值。

### 最基本内置数据类型
1、整形
    整数
2、浮点型
    小数
3、布尔型
    表示真假
4、字符串型
    由字符组成的序列。

#### 数字
Python支持整数和浮点数，
运算符  说明        示例    结果
+       加法        3+2     5
-       减法        30-5    25
*       乘法        3*6     18
/       浮点数除法   7/2     3.5
//      整数除法    7//2    3
%       模(取余)    7%4     3
**      幂          2**3    8

除数为0，会产生异常
使用divmod()函数同时得到商和余数.返回一个元组。
>>> divmod(13,3)
(4,1)

#### 整数
Python中，除10进制，还有其它三种进制：
0b或0B，二进制  0   1
0o或0O，八进行  0   1   2   3   4   5   6   7
0x或0X，十六进制 0 1 2 3 4 5 6 7 8 9 a b c d e f

#### 使用int()实现类型转换
1、浮点数直接舍去小数部分。
2、布尔值True转为1，False转为0.
3、字符串符合整数格式（浮点数格式不行）则直接转成对应整数，否则报错。

自动转型
整数和浮点数混合运算时，表达式结果自动转型成浮点数。

#### 整数可以有多大？
Python2中，int是32位。Long是64位。
Python3中，int可以存储任意大小的整数，long被取消。

### 浮点数
浮点数，称为float，用科学计数法表示。
在内存中也是按照科学计数法存储。

#### 类型转换和四舍五入
1.  float()
2.
3. round(value)可以返回四舍五入的值
注：但不会改变原有值，而是产生新的值

#### 增强型赋值运算符
运算符+、-、*、/、//、**、% 和赋值符=结合可以构成增强型赋值运算符
增强型赋值运算符中间不能加空格

#### 时间的表示
计算机中时间的表示是从“1970年1月1日 00:00:00”开始，以毫秒进行计算。这个时间称为“unix时间点”。
python中可以通过time.time()获得当前时刻，返回的值是以秒为单位，带微秒(1/1000毫秒)精度的浮点数值。

#### 定义多点坐标，给出折线，并计算距离

#### 布尔值
Python2中没有关键字，用数字0表示False，用数字1表示True
Python3中定义了关键字，但本质上还是数字0和1，可以和数字相加。

#### 比较运算符
==
!=
>
<
>=
<=

#### 逻辑运算符
运算符      格式    说明
or  逻辑或  x or y  x为true,则不计算y，直接返回true
and 逻辑与  x and y x为true,则返回y,x为true，
not 逻辑非  not x

#### 同一运算符
用于比较两个对象的存储单元，实际比较的是对象的地址。

is 与 == 区别：
is 用于判断两个变量引用对象是否为同一个，既比较对象的地址。
== 用于判断引用变量对象的值是否相等，默认调用对象的__eq__()方法。
is 运算符比 == 效率高，在变量和None进行比较时，应该使用 is。

整数缓存问题
Python仅仅对比较小的整数对象进行缓存(范围为[-5,256])缓存起来，以供重复使用，而并非所有整数对象。
注意：这仅仅是在命令行中执行，而保存文件执行，结果是不一样的，这是因为解释器做了一部分优化（范围是[-5,任意正整数]）。

### 字符串
#### 字符串的基本特点
字符串的本质是：字符序列。Python中字符串是不可变的，我们无法对原字符串做任何修改。
Python不支持单字符类型，单字符也是作为一个字符串使用的。

#### 字符串的编码
Python3直接支持Unicode，可以表示任何书面语言的字符。Python3的字符默认就是16位Unicode编码，ASCII码是Unicode编码的子集。
使用内置函数ord()可以把字符转换成对应的Unicode码。
使用内置的chr()可以把十进行数字转换成字符。

#### 引号创建字符串
可以通过单引号和双引号创建字符串。

连续三个单引号或三个双引号，可以创建多行字符串。

#### 空字符串和len()函数
Python允许空字符串存在，不包含任何字符且长度为0.
len()用于计算字符串含有多少字符。

#### 转义字符
我们可以使用“\+特殊字符”，实现某些难以用字符表示的效果。
常见的转义字符有这些：
转义字符    描述
\(在行尾时) 续行符
\\          反斜杠符号
\'          单引号
\"          双引号
\b          退格(Backspace)
\n          换行
\t          横向制表符
\r          回车

#### 字符串拼接
1. 可以使用+将多个字符串拼接起来。例如：’aa’ + ’bb’ ==>’aabb’。
(1) 如果+两边都是字符串，则拼接。
(2) 如果+两边都是数字，则加法运算。
(3) 如果+两边类型不同，则抛出异常。
2. 可以将多个字面字符串直接放到一起实现拼接。例如：’aa’’bb’==>’aabb’

### 字符串复制
使用*可以实现字符串复制。
【操作】字符串复制操作
>>> a = 'Sxt'*3
>>> a
'SxtSxtSxt'

#### 不换行打印
我们前面调用 print 时，会自动打印一个换行符。有时，我们不想换行，不想自动添加换行
符。我们可以自己通过参数 end = “任意字符串”。实现末尾添加任何内容

#### 从控制台读取字符串
我们可以使用 input()从控制台读取键盘输入的内容

#### str()实现数字转型字符串
str()可以帮助我们将其他数据类型转换为字符串。
当我们调用 print()函数时，解释器自动调用了 str()将非字符串的对象转成了字符串。

#### 使用[]提取字符
字符串的本质就是字符序列，我们可以通过在字符串后面添加[]，在[]里面指定偏移量，可以提取该位置的单个字符。
正向搜索：
    最左侧第一个字符，偏移量是 0，第二个偏移量是 1，以此类推。直到 len(str)-1为止。
反向搜索：
    最右侧第一个字符，偏移量是-1，倒数第二个偏移量是-2，以此类推，直到-len(str)为止

#### replace()实现字符串替换
字符串是“不可改变”的，我们通过[]可以获取字符串指定位置的字符，但是我们不能改变字符串。
字符串不可改变。但是，我们确实有时候需要替换某些字符。这时，只能通过创建新的字符串来实现。
整个过程中，实际上我们是创建了新的字符串对象，并指向了变量 a，而不是修改了以前的字符串。 

#### 字符串切片 slice 操作
切片 slice 操作可以让我们快速的提取子字符串。标准格式为：
[起始偏移量 start：终止偏移量 end：步长 step]

典型操作(三个量为正数的情况)如下：
操作和说明                                          示例            结果
[:] 提取整个字符串                                  “abcdef”[:]     “abcdef”
[start:] 从 start 索引开始到结尾                    “abcdef”[2:]    “cdef”
[:end]  从头开始知道 end-1                          “abcdef”[:2]    “ab”
[start:end] 从 start 到 end-1                     “abcdef”[2:4]    “cd”
[start:end:step] 从 start 提取到end-1，步长是 step  “abcdef”[1:5:2]  “bd”

其他操作（三个量为负数）的情况：
示例                                说明                            结果
"abcdefghijklmnopqrstuvwxyz"[-3:]   倒数三个                        “xyz”
"abcdefghijklmnopqrstuvwxyz"[-8:-3] 倒数第八个到倒数第三个(包头不包尾)  'stuvw'
"abcdefghijklmnopqrstuvwxyz"[::-1]  步长为负，从右到左反向提取          'zyxwvutsrqponmlkjihgfedcba'

切片操作时，起始偏移量和终止偏移量不在[0,字符串长度-1]这个范围，也不会报错。起始
偏移量小于 0 则会当做 0，终止偏移量大于“长度-1”会被当成-1。

#### split()分割和 join()合并
split()可以基于指定分隔符将字符串分隔成多个子字符串(存储到列表中)。如果不指定分隔符，则默认使用空白字符(换行符/空格/制表符)。
join()的作用和 split()作用刚好相反，用于将一系列子字符串连接起来。
>>> a = ['sxt','sxt100','sxt200']
>>> '*'.join(a)
'sxt*sxt100*sxt200'

拼接字符串要点：
使用字符串拼接符+，会生成新的字符串对象，因此不推荐使用+来拼接字符串。推荐使用 join 函数，因为 join 函数在拼接字符串之前会计算所有字符串的长度，然后逐一拷贝，仅新建一次对象.

#### 字符串驻留机制和字符串比较
字符串驻留：仅保存一份相同且不可变字符串的方法，不同的值被存放在字符串驻留池中。
Python 支持字符串驻留机制，对于符合标识符规则的字符串（仅包含下划线（_）、字母
和数字）会启用字符串驻留机制驻留机制。

#### 字符串比较和同一性
我们可以直接使用==,!=对字符串进行比较，是否含有相同的字符。
我们使用 is / not is，判断两个对象是否同一个对象。比较的是对象的地址，即 id(obj1)是
否和 id(obj2)相等。 

#### 成员操作符
in /not in 关键字，判断某个字符(子字符串)是否存在于字符串中。 

#### 字符串常用方法汇总
方法和使用示例           说明               结果
len(a)                  符串长度            96
a.startswith('我是高淇') 以指定字符串开头    True
a.endswith('过我')       以指定字符串结尾    True
a.find('高')        第一次出现指定字符串的位置  2
a.rfind('高')       最后一次出现指定字符串的位置 29
a.count("编程")     指定字符串出现了几次         3
a.isalnum()         所有字符全是字母或数字      False

#### 去除首尾信息
我们可以通过 strip()去除字符串首尾指定信息。通过 lstrip()去除字符串左边指定信息，rstrip()去除字符串右边指定信息。

#### 大小写转换
编程中关于字符串大小写转换的情况，经常遇到。

示例 说明 结果
a.capitalize() 产生新的字符串,首字母大写    'Gaoqi love programming, love sxt' 
a.title() 产生新的字符串,每个单词都首字母大写   'Gaoqi Love Programming, Love Sxt' 
a.upper() 产生新的字符串,所有字符全转成大写 'GAOQI LOVE PROGRAMMING, LOVESXT' 
a.lower() 产生新的字符串,所有字符全转成小写 'gaoqi love programming, love sxt'  
a.swapcase() 产生新的,所有字母大小写转换    'GAOQI LOVE PROGRAMMING, LOVE sxt

#### 格式排版
center()、ljust()、rjust()这三个函数用于对字符串实现排版。示例如下：
>>> a="SXT" 
>>> a.center(10,"*")
'***SXT****' 
>>> a.center(10)
' SXT ' 
>>> a.ljust(10,"*")
'SXT*******'

#### 其他方法
1. isalnum() 是否为字母或数字
2. isalpha() 检测字符串是否只由字母组成(含汉字)。
3. isdigit() 检测字符串是否只由数字组成。
4. isspace() 检测是否为空白符
5. isupper() 是否为大写字母
6. islower() 是否为小写字母

#### 字符串的格式化
#### format()基本用法
Python2.6 开始，新增了一种格式化字符串的函数 str.format()，它增强了字符串格式化的功能。
基本语法是通过 {} 和 : 来代替以前的 % 。
format 函数可以接受不限个参数，位置可以不按顺序。

我们通过示例进行格式化的学习。
>>> a = "名字是:{0},年龄是：{1}" 
>>> a.format("高淇",18)
'名字是:高淇,年龄是：18' 
>>> a.format("高希希",6)
'名字是:高希希,年龄是：6' 
>>> b = "名字是：{0}，年龄是{1}。{0}是个好小伙" 
>>> b.format("高淇",18)
'名字是：高淇，年龄是 18。高淇是个好小伙' 
>>> c = "名字是{name}，年龄是{age}" 
>>> c.format(age=19,name='高淇')
'名字是高淇，年龄是 19' 

我们可以通过{索引}/{参数名}，直接映射参数值，实现对字符串的格式化，非常方便。

#### 填充与对齐
填充常跟对齐一起使用
^、<、>分别是居中、左对齐、右对齐，后面带宽度
:号后面带填充的字符，只能是一个字符，不指定的话默认是用空格填充

>>> "{:*>8}".format("245")
'*****245' 
>>> "我是{0},我喜欢数字{1:*^8}".format("高淇","666")
'我是高淇,我喜欢数字**666***'

#### 数字格式化
浮点数通过 f，整数通过 d 进行需要的格式化。案例如下：
>>> a = "我是{0}，我的存款有{1:.2f}" 
>>> a.format("高淇",3888.234342)
'我是高淇，我的存款有 3888.23'

其他格式，供大家参考：
数字        格式        输出    描述
3.1415926   {:.2f}      3.14    保留小数点后两位
3.1415926   {:+.2f}     3.14    带符号保留小数点后两位
2.71828     {:.0f}      3       不带小数
5           {:0>2d}     05      数字补零 (填充左边, 宽度为 2)
5           {:x<4d}     5xxx    数字补 x (填充右边, 宽度为 4)
10          {:x<4d}     10xx    数字补 x (填充右边, 宽度为 4)
1000000     {:,}        1,000,000   以逗号分隔的数字格式
0.25        {:.2%}      25.00%  百分比格式
1000000000  {:.2e}      1.00E+09   指数记法
13          {:10d}      13       右对齐 (默认, 宽度为 10)
13          {:<10d}     13      左对齐 (宽度为 10)
13          {:^10d}     13      中间对齐 (宽度为 10)

#### 可变字符串
在 Python 中，字符串属于不可变对象，不支持原地修改，如果需要修改其中的值，智能创建新的字符串对象。但是，经常我们确实需要原地修改字符串，可以使用 io.StringIO对象或 array 模块。

>>> import io
>>> s = "hello, sxt" >>> sio = io.StringIO(s)
>>> sio
<_io.StringIO object at 0x02F462B0>
>>> sio.getvalue()
'hello, sxt' 
>>> sio.seek(7)
7
>>> sio.write("g")
1
>>> sio.getvalue()
'hello, gxt'

#### 本章实操作业
1、(5+10*x)/5-13*(y-1)(a+b)/x+9(5/x+(12+x)/y)
2、mone = input()
print( mone * 12)
3、"爱你一百遍"*100
4、” to be ro not to be“[::-1]
5、" sxtsxtsxtsxtsxt"[1::3]
6、a is b True  a和b的值符合命名规则，可以驻留内存，是同一个对象
c is d False    c和d不可驻留内存，是不同的对象
7、”名字是高淇，年龄是19“

## 第 3 章 序列
序列是一种数据存储方式，用来存储一系列的数据。在内存中，序列就是一块用来存放多个值的连续的内存空间。

序列中存储的是整数对象的地址，而不是整数对象的值。python中常用的序列结构有：
字符串、列表、元组、字典、集合

我们上一章学习的字符串就是一种序列。关于字符串里面很多操作，在这一章中仍然会用到，

### 列表简介
列表：用于存储任意数目、任意类型的数据集合。
列表是内置可变序列，是包含多个元素的有序连续的内存空间。列表定义的标准语法格式：
a = [10,20,30,40]
其中，10,20,30,40 这些称为：列表 a 的元素。
列表中的元素可以各不相同，可以是任意类型。比如：
a = [10,20,'abc',True]
列表对象的常用方法汇总如下，方便大家学习和查阅。

方法                要点 描述
list.append(x)      增加元素    将元素 x 增加到列表 list 尾部
list.extend(aList)  增加元素    将列表 alist 所有元素加到列表 list 尾部
list.insert(index,x) 增加元素   在列表 list 指定位置 index 处插入元素 x
list.remove(x)      删除元素    在列表 list 中删除首次出现的指定元素 x
list.pop([index])   删除元素    删除并返回列表 list 指定为止 index 处的元素，默认是最后一个元素
list.clear()        删除所有元素 删除列表所有元素，并不是删除列表对象
list.index(x)       访问元素    返回第一个 x 的索引位置，若不存在 x 元素抛出异常
list.count(x)       计数        返回指定元素 x 在列表 list 中出现的次数
len(list)           列表长度    返回列表中包含元素的个数
list.reverse()      翻转列表    所有元素原地翻转
list.sort()         排序        所有元素原地排序
list.copy()         浅拷贝      返回列表对象的浅拷贝

Python 的列表大小可变，根据需要随时增加或缩小。
字符串和列表都是序列类型，一个字符串是一个字符序列，一个列表是任何元素的序列。我们前面学习的很多字符串的方法，在列表中也有类似的用法，几乎一模一样

### 列表的创建
####基本语法[]创建
>>> a = [10,20,'gaoqi','sxt']
>>> a = [] #创建一个空的列表对象

#### list()创建
使用 list()可以将任何可迭代的数据转化成列表。
>>> a = list() #创建一个空的列表对象
>>> a = list(range(10))
>>> a
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
>>> a = list("gaoqi,sxt")
>>> a
['g', 'a', 'o', 'q', 'i', ',', 's', 'x', 't']

#### range()创建整数列表
range()可以帮助我们非常方便的创建整数列表，这在开发中及其有用。语法格式为：
range([start,] end [,step])
start 参数：可选，表示起始数字。默认是 0
end 参数：必选，表示结尾数字。
step 参数：可选，表示步长，默认为 1

python3 中 range()返回的是一个 range 对象，而不是列表。我们需要通过 list()方法将其转换成列表对象。

#### 推导式生成列表(简介一下，重点在 for 循环后讲)
使用列表推导式可以非常方便的创建列表，在开发中经常使用。但是，由于涉及到 for 循环和 if 语句。在此，仅做基本介绍。在我们控制语句后面，会详细讲解更多列表推导式的细节。
>>> a = [x*2 for x in range(5)] #循环创建多个元素
>>> a
[0, 2, 4, 6, 8]
>>> a = [x*2 for x in range(100) if x%9==0] #通过 if 过滤元素
>>> a
[0, 18, 36, 54, 72, 90, 108, 126, 144, 162, 180, 198]

### 列表元素的增加和删除
当列表增加和删除元素时，列表会自动进行内存管理，大大减少了程序员的负担。但这
个特点涉及列表元素的大量移动，效率较低。除非必要，我们一般只在列表的尾部添加元素
或删除元素，这会大大提高列表的操作效率。

#### append()方法
原地修改列表对象，是真正的列表尾部添加新的元素，速度最快，推荐使用。

#### +运算符操作
并不是真正的尾部添加元素，而是创建新的列表对象；将原列表的元素和新列表的元素依次复制到新的列表对象中。这样，会涉及大量的复制操作，对于操作大量元素不建议使用。

#### extend()方法
将目标列表的所有元素添加到本列表的尾部，属于原地操作，不创建新的列表对象

#### insert()插入元素
使用 insert()方法可以将指定的元素插入到列表对象的任意制定位置。
这样会让插入位置后面所有的元素进行移动，会影响处理速度。涉及大量元素时，尽量避免使用。
类似发生这种移动的函数还有：remove()、pop()、del()，它们在删除非尾部元素时也会发生操作位置后面元素的移动

#### 乘法扩展
使用乘法扩展列表，生成一个新列表，新列表元素时原列表元素的多次重复。
适用于乘法操作的，还有：字符串、元组。

### 列表元素的删除
#### del 删除
删除列表指定位置的元素。

#### pop()方法
pop()删除并返回指定位置元素，如果未指定位置则默认操作列表最后一个元素。

#### remove()方法
删除首次出现的指定元素，若不存在该元素抛出异常。

### 列表元素访问和计数
#### 通过索引直接访问元素
我们可以通过索引直接访问元素。索引的区间在[0, 列表长度-1]这个范围。超过这个范围则会抛出异常。

#### index()获得指定元素在列表中首次出现的索引
index()可以获取指定元素首次出现的索引位置。语法是：index(value,[start,[end]])。其中，start 和 end 指定了搜索的范围。

#### count()获得指定元素在列表中出现的次数
count()可以返回指定元素在列表中出现的次数。

#### len()返回列表长度
len()返回列表长度，即列表中包含元素的个数。

#### 成员资格判断
判断列表中是否存在指定的元素，我们可以使用 count()方法，返回 0 则表示不存在，返回大于 0 则表示存在。
但是，一般我们会使用更加简洁的 in 关键字来判断，直接返回 True或 False。

### 切片操作
我们在前面学习字符串时，学习过字符串的切片操作，对于列表的切片操作和字符串类似。
切片是 Python 序列及其重要的操作，适用于列表、元组、字符串等等。切片的格式如下：

切片 slice 操作可以让我们快速提取子列表或修改。标准格式为：
[起始偏移量 start:终止偏移量 end[:步长 step]]

注：当步长省略时顺便可以省略第二个冒号

典型操作(三个量为正数的情况)如下：

操作和说明 示例 结果
[:] 提取整个列表 [10,20,30][:] [10,20,30]
[start:]从 start 索引开始到结尾[10,20,30][1:] [20,30]
[:end]从头开始知道 end-1 [10,20,30][:2] [10,20]
[start:end]从 start 到 end-1 [10,20,30,40][1:3] [20,30]
[start:end:step] 从 start 提取到 end-1，步长是 step[10,20,30,40,50,60,70][1:6:2][20, 40, 60]

其他操作（三个量为负数）的情况：
示例 说明 结果
[10,20,30,40,50,60,70][-3:] 倒数三个 [50,60,70]
[10,20,30,40,50,60,70][-5:-3] 倒数第五个到倒数第三个(包头不包尾)[30,40]
[10,20,30,40,50,60,70][::-1] 步长为负，从右到左反向提取[70, 60, 50, 40, 30, 20, 10]

切片操作时，起始偏移量和终止偏移量不在[0,字符串长度-1]这个范围，也不会报错。
起始偏移量小于 0 则会当做 0，终止偏移量大于“长度-1”会被当成”长度-1”。

#### 列表的遍历
for obj in listObj:
print(obj)

#### 复制列表所有的元素到新列表对象
我们可以通过如下简单方式，实现列表元素内容的复制：
list1 = [30,40,50]
list2 = [] + list1
注：我们后面也会学习 copy 模块，使用浅复制或深复制实现我们的复制操作。

### 列表排序
#### 修改原列表，不建新列表的排序
>>> a.sort() #默认是升序排列
>>> a
[10, 20, 30, 40]
>>> a = [10,20,30,40]
>>> a.sort(reverse=True) #降序排列
>>> a
[40, 30, 20, 10]
>>> import random
>>> random.shuffle(a) #打乱顺序
>>> a
[20, 40, 30, 10]

#### 建新列表的排序
我们也可以通过内置函数 sorted()进行排序，这个方法返回新列表，不对原列表做修改。
>>> a = sorted(a) #默认升序
>>> a
[10, 20, 30, 40]
>>> c = sorted(a,reverse=True) #降序
>>> c
[40, 30, 20, 10]

#### reversed()返回迭代器
内置函数 reversed()也支持进行逆序排列，与列表对象 reverse()方法不同的是，内置函数reversed()不对原列表做任何修改，只是返回一个逆序排列的迭代器对象。

我们打印输出 c 发现提示是：list_reverseiterator。也就是一个迭代对象。同时，我们使用
list(c)进行输出，发现只能使用一次。第一次输出了元素，第二次为空。那是因为迭代对象
在第一次时已经遍历结束了，第二次不能再使用。
注：关于迭代对象的使用，后续章节会进行详细讲解。

### 列表相关的其他内置函数汇总
#### max 和 min
用于返回列表中最大和最小值。

#### sum
对数值型列表的所有元素进行求和操作，对非数值型列表运算则会报错。

### 多维列表
#### 二维列表
一维列表可以帮助我们存储一维、线性的数据。
二维列表可以帮助我们存储二维、表格的数据。

### 元组 tuple
列表属于可变序列，可以任意修改列表中的元素。元组属于不可变序列，不能修改元组中的元素。
因此，元组没有增加元素、修改元素、删除元素相关的方法。
因此，我们只需要学习元组的创建和删除，元组中元素的访问和计数即可。元组支持如下操作：
1. 索引访问
2. 切片操作
3. 连接操作
4. 成员关系操作
5. 比较运算操作
6. 计数：元组长度 len()、最大值 max()、最小值 min()、求和 sum()等。

#### 元组的创建
##### 1. 通过()创建元组。小括号可以省略。
a = (10,20,30) 或者 a = 10,20,30
如果元组只有一个元素，则必须后面加逗号。这是因为解释器会把(1)解释为整数 1，(1,)解释为元组。

##### 2. 通过 tuple()创建元组
tuple(可迭代的对象)

总结：
tuple()可以接收列表、字符串、其他序列类型、迭代器等生成元组。
list()可以接收元组、字符串、其他序列类型、迭代器等生成列表。

#### 元组的元素访问和计数
1. 元组的元素不能修改
2. 元组的元素访问和列表一样，只不过返回的仍然是元组对象
3. 列表关于排序的方法 list.sorted()是修改原列表对象，元组没有该方法。
    如果要对元组排序，只能使用内置函数 sorted(tupleObj)，并生成新的列表对象。

#### zip
zip(列表 1，列表 2，...)将多个列表对应位置的元素组合成为元组，并返回这个 zip 对象。

#### 生成器推导式创建元组
从形式上看，生成器推导式与列表推导式类似，只是生成器推导式使用小括号。
列表推导式直接生成列表对象，生成器推导式生成的不是列表也不是元组，而是一个生成器对象。
我们可以通过生成器对象，转化成列表或者元组。也可以使用生成器对象的__next__()方法进行遍历，或者直接作为迭代器对象来使用。
不管什么方式使用，元素访问结束后，如果需要重新访问其中的元素，必须重新创建该生成器对象

#### 元组总结
1. 元组的核心特点是：不可变序列。
2. 元组的访问和处理速度比列表快。
3. 与整数和字符串一样，元组可以作为字典的键，列表则永远不能作为字典的键使用。

### 字典介绍
字典是“键值对”的无序可变序列，字典中的每个元素都是一个“键值对”，包含：“键对象”和“值对象”。
可以通过“键对象”实现快速获取、删除、更新对应的“值对象”。列表中我们通过“下标数字”找到对应的对象。字典中通过“键对象”找到对应的“值对象”。
“键”是任意的不可变数据，比如：整数、浮点数、字符串、元组。但是：列表、字典、集合这些可变对象，不能作为“键”。
并且“键”不可重复。“值”可以是任意的数据，并且可重复。

一个典型的字典的定义方式：
a = {'name':'gaoqi','age':18,'job':'programmer'}

#### 字典的创建
1. 我们可以通过{}、dict()来创建字典对象。
>>> a = {'name':'gaoqi','age':18,'job':'programmer'}
>>> b = dict(name='gaoqi',age=18,job='programmer')
>>> a = dict([("name","gaoqi"),("age",18)])

2. 通过 zip()创建字典对象
>>> k = ['name','age','job']
>>> v = ['gaoqi',18,'techer']
>>> d = dict(zip(k,v))

3. 通过 fromkeys 创建值为空的字典
>>> a = dict.fromkeys(['name','age','job'])

### 字典元素的访问
1. 通过 [键] 获得“值”。若键不存在，则抛出异常。

2. 通过 get()方法获得“值”。推荐使用。
优点是：指定键不存在，返回 None；也可以设定指定键不存在时默认返回的对象。推荐使用 get()获取“值对象”。

3. 列出所有的键值对
>>> a.items()
dict_items([('name', 'gaoqi'), ('age', 18), ('job', 'programmer')])

4. 列出所有的键，列出所有的值
>>> a.keys()
dict_keys(['name', 'age', 'job'])
>>> a.values()
dict_values(['gaoqi', 18, 'programmer'])

5. len() 键值对的个数

6. 检测一个“键”是否在字典中 in

### 字典元素添加、修改、删除
1. 给字典新增“键值对”。如果“键”已经存在，则覆盖旧的键值对；如果“键”不存在，则新增“键值对”。

2. 使用 update()将新字典中所有键值对全部添加到旧字典对象上。如果 key 有重复，则直接覆盖。

3. 字典中元素的删除，可以使用 del()方法；或者 clear()删除所有键值对；pop()删除指定键值对，并返回对应的“值对象”；

4. popitem() ：随机删除和返回该键值对。
字典是“无序可变序列”，因此没有第一个元素、最后一个元素的概念；
popitem 弹出随机的项，因为字典并没有"最后的元素"或者其他有关顺序的概念。
若想一个接一个地移除并处理项，这个方法就非常有效（因为不用首先获取键的列表）。

#### 序列解包
序列解包可以用于元组、列表、字典。序列解包可以让我们方便的对多个变量赋值。
>>> (a,b,c)=(9,8,10)
>>> [a,b,c]=[10,20,30]

序列解包用于字典时，默认是对“键”进行操作； 如果需要对键值对操作，则需要使用items()；如果需要对“值”进行操作，则需要使用 values()；

### 字典核心底层原理(重要)
字典对象的核心是散列表。散列表是一个稀疏数组（总是有空白元素的数组），数组的每个单元叫做 bucket。每个 bucket 有两部分：一个是键对象的引用，一个是值对象的引用。
由于，所有 bucket 结构和大小一致，我们可以通过偏移量来读取指定 bucket。

#### 将一个键值对放进字典的底层过程
假设字典 a 对象创建完后，数组长度为 8：
我们要把”name”=”gaoqi”这个键值对放到字典对象 a 中，首先第一步需要计算键”name”的散列值。Python 中可以通过 hash()来计算。
>>> bin(hash("name"))
'-0b1010111101001110110101100100101'
由于数组长度为 8，我们可以拿计算出的散列值的最右边 3 位数字作为偏移量，即“101”，十进制是数字 5。我们查看偏移量 5，对应的 bucket 是否为空。如果为空，则将键值对放进去。如果不为空，则依次取右边 3 位作为偏移量，即“100”，十进制是数字4。再查看偏移量为 4 的 bucket 是否为空。直到找到为空的 bucket 将键值对放进去。流程图如下：

扩容
python 会根据散列表的拥挤程度扩容。“扩容”指的是:创造更大的数组，将原有内容
拷贝到新数组中。
接近 2/3 时，数组就会扩容。

#### 根据键查找“键值对”的底层过程
当我们调用 a.get(“name”)，就是根据键“name”查找到“键值对”，从而找到值对象“gaoqi”。
第一步，我们仍然要计算“name”对象的散列值：
>>> bin(hash("name"))
'-0b1010111101001110110101100100101'

和存储的底层流程算法一致，也是依次取散列值的不同位置的数字。 假设数组长度为8，我们可以拿计算出的散列值的最右边 3 位数字作为偏移量，即“101”，十进制是数字5。我们查看偏移量 5，对应的 bucket 是否为空。如果为空，则返回 None。如果不为空，则将这个 bucket 的键对象计算对应散列值，和我们的散列值进行比较，如果相等。则将对应“值对象”返回。如果不相等，则再依次取其他几位数字，重新计算偏移量。依次取完后，仍然没有找到。则返回 None。流程图如下：

用法总结：
1. 键必须可散列
    (1) 数字、字符串、元组，都是可散列的。
    (2) 自定义对象需要支持下面三点：
        1 支持 hash()函数
        2 支持通过__eq__()方法检测相等性。
        3 若 a==b 为真，则 hash(a)==hash(b)也为真。
2. 字典在内存中开销巨大，典型的空间换时间。
3. 键查询速度很快
4. 往字典里面添加新建可能导致扩容，导致散列表中键的次序变化。因此，不要在遍历字典的同时进行字典的修改。

### 集合
集合是无序可变，元素不能重复。实际上，集合底层是字典实现，集合的所有元素都是字典中的“键对象”，因此是不能重复的且唯一的。

#### 集合创建和删除
1. 使用{}创建集合对象，并使用 add()方法添加元素
>>> a = {3,5,7}

2. 使用 set()，将列表、元组等可迭代对象转成集合。如果原来数据存在重复数据，则只保留一个。
>>> a = ['a','b','c','b']

3. remove()删除指定元素；clear()清空整个集合

#### 集合相关操作
像数学中概念一样，Python 对集合也提供了并集、交集、差集等运算。我们给出示例：
>>> a = {1,3,'sxt'}
>>> b = {'he','it','sxt'}
>>> a|b #并集
{1, 3, 'sxt', 'he', 'it'}
>>> a&b #交集
{'sxt'}
>>> a-b #差集
{1, 3}
>>> a.union(b) #并集
{1, 3, 'sxt', 'he', 'it'}
>>> a.intersection(b) #交集
{'sxt'}
>>> a.difference(b) #差集
{1, 3}

### 章节实操作业
1、
2、list(range(30,81,10))
3、
4、a = [["高小一",18,30000,"北京"],
    ["高小二",19,20000,"上海"],
    ["高小三", 20 , 10000 , "深圳"]]
5、
6、dict("支出金额":"300.15"，”支出日期“:"2018.10.18","支出人":"高淇")
7、











# Python 教程

Python 是一种易于学习又功能强大的编程语言。它提供了高效的高级数据结构，还能简单有效地面向对象编程。Python 优雅的语法和动态类型，以及解释型语言的本质，使它成为多数平台上写脚本和快速开发应用的理想语言。

Python 解释器易于扩展，可以使用 C 或 C++（或者其他可以通过 C 调用的语言）扩展新的功能和数据类型。Python 也可用于可定制化软件中的扩展程序语言。

这个教程非正式地介绍了 Python 语言和系统的基本概念和功能。最好在阅读的时候准备一个 Python 解释器进行练习。所有的例子都是相互独立的，所以这个教程也可以离线阅读。

这个教程并没有完整地介绍每一个功能，甚至可能没有涉及全部的常用功能。这个教程只介绍 Python 中最值得注意的功能，也会让你体会到这个语言的风格特色。学习完这个教程，你将可以阅读和编写 Python 模块和程序，也可以开始学习 Python 标准库。

术语对照表 也很值得一读。

##    1. 课前甜点

Python很容易使用，但它是一种真正的编程语言，提供了很多数据结构，也支持大型程序。
Python 允许你划分程序模块，在其他的 Python 程序中重用。
Python是一种解释型语言，不需要编译和链接。
Python程序的书写是紧凑而易读的。
Python是“可扩展的”

##    2. 使用 Python 解释器
###        2.1. 调用解释器
通过命令启动Python 解释器
py
python3
在主提示符中输入文件结束字符（在 Unix 系统中是 Control-D，Windows 系统中是 Control-Z）就退出解释器并返回退出状态为0。
如果这样不管用，你还可以写这个命令退出：quit()。
另一种启动解释器的方式是 python -c command [arg] ...，其中 command 要换成想执行的指令，就像命令行的 -c 选项。
由于 Python 代码中经常会包含对终端来说比较特殊的字符，通常情况下都建议用英文单引号把 command 括起来。
有些 Python 模块也可以作为脚本使用。可以这样输入：python -m module [arg] ...，这会执行 module 的源文件，就跟你在命令行把路径写全了一样。
在运行脚本的时候，有时可能也会需要在运行后进入交互模式。这种时候在文件参数前，加上选项 -i 就可以了。
####            2.1.1. 传入参数
如果可能的话，解释器会读取命令行参数，转化为字符串列表存入 sys 模块中的 argv 变量中。执行命令 import sys 你可以导入这个模块并访问这个列表。这个列表最少也会有一个元素；如果没有给定输入参数，sys.argv[0] 就是个空字符串。如果脚本名是标准输入，sys.argv[0] 就是 '-'。使用 -c command 时，sys.argv[0] 就会是 '-c'。如果使用选项 -m module，sys.argv[0] 就是包含目录的模块全名。在 -c command 或 -m module 之后的选项不会被解释器处理，而会直接留在 sys.argv 中给命令或模块来处理。
####            2.1.2. 交互模式
在终端（tty）输入并执行指令时，我们说解释器是运行在 交互模式（interactive mode）。在这种模式中，它会显示 主提示符（primary prompt），提示输入下一条指令，通常用三个大于号（>>>）表示；连续输入行的时候，它会显示 次要提示符，默认是三个点（...）。进入解释器时，它会先显示欢迎信息、版本信息、版权声明，然后就会出现提示符
###        2.2. 解释器的运行环境
####            2.2.1. 源文件的字符编码
##    3. Python 的非正式介绍
###        3.1. Python 作为计算器使用
####            3.1.1. 数字
####            3.1.2. 字符串
####            3.1.3. 列表
###        3.2. 走向编程的第一步
##    4. 其他流程控制工具
###        4.1. if 语句
###        4.2. for 语句
###        4.3. range() 函数
###        4.4. break 和 continue 语句，以及循环中的 else 子句
###        4.5. pass 语句
###        4.6. 定义函数
###        4.7. 函数定义的更多形式
####            4.7.1. 参数默认值
####            4.7.2. 关键字参数
####            4.7.3. 特殊参数
#####                4.7.3.1. 位置或关键字参数
#####                4.7.3.2. 仅限位置参数
#####                4.7.3.3. 仅限关键字参数
#####                4.7.3.4. 函数示例
#####                4.7.3.5. 概括
####            4.7.4. 任意的参数列表
####            4.7.5. 解包参数列表
####            4.7.6. Lambda 表达式
####            4.7.7. 文档字符串
####            4.7.8. 函数标注
###        4.8. 小插曲：编码风格
##    5. 数据结构
###        5.1. 列表的更多特性
####            5.1.1. 列表作为栈使用
####            5.1.2. 列表作为队列使用
####            5.1.3. 列表推导式
####            5.1.4. 嵌套的列表推导式
###        5.2. del 语句
###        5.3. 元组和序列
###        5.4. 集合
###        5.5. 字典
###        5.6. 循环的技巧
###        5.7. 深入条件控制
###        5.8. 序列和其它类型的比较
##    6. 模块
###        6.1. 有关模块的更多信息
####            6.1.1. 以脚本的方式执行模块
####            6.1.2. 模块搜索路径
####            6.1.3. “编译过的”Python文件
###        6.2. 标准模块
###        6.3. dir() 函数
###        6.4. 包
####            6.4.1. 从包中导入 *
####            6.4.2. 子包参考
####            6.4.3. 多个目录中的包
##    7. 输入输出
###        7.1. 更漂亮的输出格式
####            7.1.1. 格式化字符串文字
####            7.1.2. 字符串的 format() 方法
####            7.1.3. 手动格式化字符串
####            7.1.4. 旧的字符串格式化方法
###        7.2. 读写文件
####            7.2.1. 文件对象的方法
####            7.2.2. 使用 json 保存结构化数据
##    8. 错误和异常
###        8.1. 语法错误
###        8.2. 异常
###        8.3. 处理异常
###        8.4. 抛出异常
###        8.5. 用户自定义异常
###        8.6. 定义清理操作
###        8.7. 预定义的清理操作
##    9. 类
###        9.1. 名称和对象
###        9.2. Python 作用域和命名空间
####            9.2.1. 作用域和命名空间示例
###        9.3. 初探类
####            9.3.1. 类定义语法
####            9.3.2. 类对象
####            9.3.3. 实例对象
####            9.3.4. 方法对象
####            9.3.5. 类和实例变量
###        9.4. 补充说明
###        9.5. 继承
####            9.5.1. 多重继承
###        9.6. 私有变量
###        9.7. 杂项说明
###        9.8. 迭代器
###        9.9. 生成器
###        9.10. 生成器表达式
##    10. 标准库简介
###        10.1. 操作系统接口
###        10.2. 文件通配符
###        10.3. 命令行参数
###        10.4. 错误输出重定向和程序终止
###        10.5. 字符串模式匹配
###        10.6. 数学
###        10.7. 互联网访问
###        10.8. 日期和时间
###        10.9. 数据压缩
###        10.10. 性能测量
###        10.11. 质量控制
###        10.12. 自带电池
##    11. 标准库简介 —— 第二部分
###        11.1. 格式化输出
###        11.2. 模板
###        11.3. 使用二进制数据记录格式
###        11.4. 多线程
###        11.5. 日志
###        11.6. 弱引用
###        11.7. 用于操作列表的工具
###        11.8. 十进制浮点运算
##    12. 虚拟环境和包
###        12.1. 概述
###        12.2. 创建虚拟环境
###        12.3. 使用pip管理包
##    13. 接下来？
##    14. 交互式编辑和编辑历史
###        14.1. Tab 补全和编辑历史
###        14.2. 默认交互式解释器的替代品
##    15. 浮点算术：争议和限制
###        15.1. 表示性错误
##    16. 附录
###        16.1. 交互模式
####            16.1.1. 错误处理
####            16.1.2. 可执行的Python脚本
####            16.1.3. 交互式启动文件
####            16.1.4. 定制模块

